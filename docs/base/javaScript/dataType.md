# 数据类型

## `javaScript` 的 `8` 种数据类型

### `7` 种基本数据类型

`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol（es6 新增）`、`Biglent（es10 新增）`

在内存中占据固定大小，保存在栈内存中

### `1` 种引用数据类型

`Object`

里面包含 `Function(函数)`，其他还有`Array(数组)`、`Date(日期)`、`RegExp(正则表达式)`等。

特殊的基本包装类型(`String`、`Number`、`Boolean`) 以及单体内置对象(`Global`、`Math`)等。

引用类型的值是对象，保存在堆内存中，而栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址。

### `null` 与 `undefined` 的区别

- `null` 是表示一个`'无'`的对象，转为数值是 `0`。

- `undefined` 是表示一个`'无'`的原始值，转为数值是 `NAN`。

- `null` 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象

- `undefined` 表示`”缺少值”`，就是此处应该有一个值,但是还没有定义，典型用法是：

  - 变量被声明了，但没有赋值时，就等于 `undefined`

  - 调用函数时，应该提供的参数没有提供，该参数等于 `undefined`

  - 对象没有赋值属性，该属性的值为 `undefined`

  - 函数没有返回值时，默认返回 `undefined`

- `null` 表示`”没有对象”`，即该处不应该有值，典型用法是：

  - 作为函数的参数，表示该函数的参数不是对象

  - 作为对象原型链的终点

### `===` 和 `==` 的区别

前者会⾃动转换类型，再判断是否相等，后者不会⾃动类型转换，直接去⽐较。

### `0.1 + 0.2 !== 0.3`

- 浮点数在计算机中无法精确表示，这些值在被存储时会被 截断，导致它们在内存中存储的值与它们的真实值之间有微小的差异。

- 运算时的精度丢失，由于 `0.1` 和 `0.2` 不能被精确表示，运算时也会产生一定的误差。因此，当你计算 `0.1 + 0.2` 时，结果并不是精确的 `0.3`，而是接近 `0.3` 的一个值

::: tip 解决

- 使用四舍五入：将结果舍入到一定的小数位数，通常可以通过设置小数点后的位数来减少误差。

```js
console.log((0.1 + 0.2).toFixed(1)) // "0.3"
console.log(Number((0.1 + 0.2).toFixed(10))) // 0.3
```

- 使用整数运算： 你可以通过将小数放大为整数进行运算，然后再除以相应的倍数。比如把 `0.1` 和 `0.2` 乘以 `10` 变成整数 `1` 和 `2`，再进行运算，最后除以 `10`

```js
console.log((0.1 * 10 + 0.2 * 10) / 10) // 0.3
```

- 使用第三方库：[<u>number-precision</u>](https://www.npmjs.com/package/number-precision)

:::
