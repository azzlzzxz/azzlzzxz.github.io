import{_ as p,B as c,o as t,c as r,D as e,z as o,x as s,Q as a,a as n}from"./chunks/framework.a5035e6c.js";const q=JSON.parse('{"title":"Node 的事件循环机制","description":"","frontmatter":{},"headers":[],"relativePath":"node/base/eventLoop.md","lastUpdated":1724914295000}'),i={name:"node/base/eventLoop.md"},d=a("",5),y=s("ul",null,[s("li",null,[s("code",null,"timers:"),n(" 执行 "),s("code",null,"setTimeout"),n(" 和 "),s("code",null,"setInterval"),n(" 中到期的 "),s("code",null,"callback"),n("。")]),s("li",null,[s("code",null,"pending callback:"),n(" 上一轮循环中少数的 "),s("code",null,"callback"),n(" 会放在这一阶段执行。")]),s("li",null,[s("code",null,"idle, prepare:"),n(" 仅在内部使用。")]),s("li",null,[s("code",null,"poll:"),n(" 最重要的阶段，执行 "),s("code",null,"pending"),n(),s("code",null,"callback"),n("，在适当的情况下会阻塞在这个阶段。")]),s("li",null,[s("code",null,"check:"),n(" 执行 "),s("code",null,"setImmediate"),n(" 的 "),s("code",null,"callback"),n("。")]),s("li",null,[s("code",null,"close callbacks:"),n(" 执行 close 事件的 "),s("code",null,"callback"),n("，例如 "),s("code",null,"socket.on(‘close’[,fn])"),n("或者 "),s("code",null,"http.server.on('close, fn)"),n("。")])],-1),F=a("",36),D=s("code",null,"I/O",-1),m=s("code",null,"setImmediate",-1),b=s("code",null,"I/O",-1),u=s("code",null,"poll",-1),B=s("code",null,"poll",-1),A=s("code",null,"check",-1),E=s("code",null,"setImmediate",-1),h=a("",9);function _(k,g,C,v,f,I){const l=c("font");return t(),r("div",null,[d,e(l,{color:"#5887ff"},{default:o(()=>[y]),_:1}),F,s("p",null,[s("strong",null,[e(l,{color:"#FF4444"},{default:o(()=>[n("但是，如果你把这两个函数放入一个 "),D,n(" 循环内调用，"),m,n(" 总是被优先调用：因为 "),b,n(" 操作是在 "),u,n(" 阶段进行的，"),B,n(" 阶段之后是 "),A,n("（也就是调用 "),E,n("）。")]),_:1})])]),h])}const x=p(i,[["render",_]]);export{q as __pageData,x as default};
