import{_ as r,B as n,o as d,c as i,N as t,x as a,a as o,D as l,z as c}from"./chunks/framework.2f525601.js";const x=JSON.parse('{"title":"前端发布策略","description":"","frontmatter":{},"headers":[],"relativePath":"capital/deploy/release.md","lastUpdated":1728706279000}'),p={name:"capital/deploy/release.md"};function h(u,e,g,m,_,f){const s=n("font");return d(),i("div",null,[e[6]||(e[6]=t('<h1 id="前端发布策略" tabindex="-1">前端发布策略 <a class="header-anchor" href="#前端发布策略" aria-label="Permalink to &quot;前端发布策略&quot;">​</a></h1><p>前端发布的本质，其实是静态资源的发布，一般是 <code>js</code>、<code>css</code>,而不包括动态渲染出来的<code>html</code>模版。</p><h2 id="野生状态下的前端资源" tabindex="-1">野生状态下的前端资源 <a class="header-anchor" href="#野生状态下的前端资源" aria-label="Permalink to &quot;野生状态下的前端资源&quot;">​</a></h2><ul><li>有一个<code>HTML</code></li><li><code>HTML</code>中引入一个<code>CSS</code></li><li><code>CSS</code>和<code>HTML</code>模版都有服务器反向代理</li></ul><p>这时候他们的网络时序图会如下图所示，<code>html</code> 和 <code>css</code> 会依此加载：</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_init.jpg" alt="release_init"></p><p>用 <code>HTTP</code> 的缓存提高资源的加载速度</p><h2 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h2><p>使用协商缓存的话，浏览器去请求资源，服务器会告诉浏览器这个资源已经多久没有改变过了，浏览器发现这个时间内自己请求过这个资源，于是就把缓存的资源拿出来直接使用。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_negotiate.jpg" alt="release_negotiate"></p><p>这种方式省去了重新下载整个资源的时间，但是仍然需要一次协商缓存的过程。</p><h2 id="本地缓存" tabindex="-1">本地缓存 <a class="header-anchor" href="#本地缓存" aria-label="Permalink to &quot;本地缓存&quot;">​</a></h2><p>另一种是本地缓存，在这种方式下，浏览器在发起请求之前，会对比请求的<code>url</code>，如果发现和之前一致的话，就从硬盘或是内存中，找到对应的缓存，直接使用。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_cache.jpg" alt="release_cache"></p><p>显然本地缓存对加载速度更好，但是本地缓存带来了新的问题，如果资源更新了怎么办？用户一直使用老的缓存，即使发布了新的版本，用户不是也用不上啊，那么我们就需要想办法去解决这个问题 🙋。</p><h3 id="版本号-version-控制" tabindex="-1">版本号 <code>version</code> 控制 <a class="header-anchor" href="#版本号-version-控制" aria-label="Permalink to &quot;版本号 `version` 控制&quot;">​</a></h3><p>既然本地缓存更请求的<code>url</code>有关，那么我们在请求资源的后面多加个版本的参数不就好了么，每次更新资源的时候也同步的更新参数。</p><p>比如说：所有的资源都加上一个<code>v.x.x.x</code>的版本号，在下次更新的时候修改版本号，让用户的缓存失效。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_version.jpg" alt="release_version"></p><p>但是在实际情况中，我们还发现了新的问题，对于一个大型网站来说，静态资源可能非常非常多，每天都会有新的前端代码被修改，如果其中每一个资源被修改了，我们就全量修改所有的版本号的话。那缓存的意义也就不大了。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_version_1.jpg" alt="release_version_1"></p><p>针对这个问题，我们可以用 <code>hash</code> 来解决。</p><h3 id="hash-区分" tabindex="-1"><code>hash</code> 区分 <a class="header-anchor" href="#hash-区分" aria-label="Permalink to &quot;`hash` 区分&quot;">​</a></h3><p><code>hash</code> 是一串字符串，它像是文件的一种特质，只和文件的内容有关，如果一个文件的内容变了，那么它的 <code>hash</code> 值也会变化。</p><p>利用 <code>hash</code> 的特性，我们可以把上一步的版本号改为 <code>hash</code> 值，这样的话只有被我们改动过的静态资源的缓存才会失效。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_hash.jpg" alt="release_hash"></p><p>看起来这是一种比较完美的解决方案。</p><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><p>为了进一步提升网站性能，一般都会把静态资源和动态网页分集群部署，静态资源会被部署到 <code>CDN</code> 节点上，网页中引用的资源也会变成对应的部署路径：</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_static.jpg" alt="release_static"></p><p>好了，当我要更新静态资源的时候，同时也会更新 <code>html</code> 中的引用吧，就好像这样：</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_static_1.jpg" alt="release_static_1"></p><p>页面和静态资源不在同一个机器上，我们就要面临一个问题，他们两者的部署，就必然会有一个时间差，那么是先上线页面呢，还是先上线静态资源呢？</p>',33)),a("ul",null,[a("li",null,[a("p",null,[e[1]||(e[1]=a("code",null,"先部署页面，再部署资源：",-1)),e[2]||(e[2]=o("在二者部署的时间间隔内，如果有用户访问页面，就会在新的页面结构中加载旧的资源，并且把这个旧版本的资源当做新版本缓存起来，其结果就是：")),a("strong",null,[l(s,{color:"FF9D00"},{default:c(()=>e[0]||(e[0]=[o("用户访问到了一个样式错乱的页面，除非手动刷新，否则在资源缓存过期之前，页面会一直执行错误。")])),_:1})])])]),a("li",null,[a("p",null,[e[4]||(e[4]=a("code",null,"先部署资源，再部署页面：",-1)),e[5]||(e[5]=o("在部署时间间隔之内，有旧版本资源本地缓存的用户访问网站，由于请求的页面是旧版本的，资源引用没有改变，浏览器将直接使用本地缓存，这种情况下页面展现正常；")),a("strong",null,[l(s,{color:"FF9D00"},{default:c(()=>e[3]||(e[3]=[o("但没有本地缓存或者缓存过期的用户访问网站，就会出现旧版本页面加载新版本资源的情况，导致页面执行错误，但当页面完成部署，这部分用户再次访问页面又会恢复正常了。")])),_:1})])])])]),e[7]||(e[7]=t('<h2 id="最终方案-非覆盖式发布-🌟🌟🌟" tabindex="-1">最终方案：非覆盖式发布 🌟🌟🌟 <a class="header-anchor" href="#最终方案-非覆盖式发布-🌟🌟🌟" aria-label="Permalink to &quot;最终方案：非覆盖式发布 🌟🌟🌟&quot;">​</a></h2><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/release_static_2.jpg" alt="release_static_2"></p><p>之前的方案之所以有问题，是因为在 <code>CDN</code> 上同名的文件只能有一份，它要么是老的要么是新的，不能同时存在，这种方式叫做<code>覆盖式发布</code>。</p><p><code>非覆盖式发布</code>就是指我们不通过 <code>url</code> 参数带 <code>hash</code> 的方法解决缓存问题，而是直接将 <code>hash</code> 写入到静态资源的文件名中，这样的话不同版本的同一资源，文件名也不会重复。</p><p>我们在发布时，将新的资源推送到 <code>CDN</code> 之后并不会覆盖老的资源，它们两者在 <code>CDN</code> 上同时存在，这个时候访问新页面的用户加载新的资源，访问老的页面的用户加载老的资源，各不冲突，这样就可以完美的解决资源更新的问题了。</p><div class="info custom-block"><p class="custom-block-title">相关资料</p><ul><li><a href="https://juejin.cn/post/7316202725330796571" target="_blank" rel="noreferrer"><u>前端部署真的不简单</u></a></li></ul></div>',6))])}const q=r(p,[["render",h]]);export{x as __pageData,q as default};
