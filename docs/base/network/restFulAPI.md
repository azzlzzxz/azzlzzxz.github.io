# RestFul API

- `RestFul` 是面向资源。
- `RestFul` 是一种架构的规范和约束、原则。
- `rest：`资源的表述性状态转移（表述性：客户端请求一个资源，服务器拿到这个资源）
- 资源的地址：在 `Web` 中就是 `URL`（统一资源标识符）
- 资源是 `Rest` 系统的核心概念，所有的设计都是以资源为中心。

## `RestFul` 架构应该遵循统一接口原则

不论什么样的资源，都是通过使用相同的接口进行资源的访问。

`RestFul` 可以通过一套统一的接口为 `Web`，`iOS 和 Android`提供服务。

`RestFul` 架构风格规定，数据的元操作，即 `CRUD(create, read, update 和 delete,即数据的增删查改)`操作，分别对应于 `HTTP` 方法：

- `GET` 用来获取资源
- `POST` 用来新建资源（也可以用于更新资源）
- `PUT` 用来更新资源，`DELETE` 用来删除资源，这样就统一了数据操作的接口，仅通过 `HTTP` 方法，就可以完成对数据的所有增删查改工作。

## `rest` 和 `RestFul` 的区别

- `rest` 是一种架构风格。
- `RestFul` 是遵循了 `rest` 的原则 的`web`服务。
- `retFul` 是有 `rest` 衍生出来的。

### `rest` 原则

1. 网络上的所有事物都被抽象为资源。
2. 每一个资源都有一个唯一的资源标识符。
3. 同一个资源具有多种表现形式`（xml、json 等）`。
4. 对于资源的各种操作不会改变资源的标识符。
5. 所有操作都是无状态的。

### 什么是无状态和有状态

- 有状态：后面每一个状态都依赖于前面的状态，没有一个 `url`，能够直接定位到想要的资源。
- 无状态：对每个资源请求，都不依赖于其他资源或其他请求。每个资源都可以寻址的，都有至少一个 `url` 能对其定位的。

### 在 `RestFul` 之前的操作

- <http://127.0.0.1/user/query/1> `GET`   根据用户 `id` 查询用户数据
- <http://127.0.0.1/user/save> `POST` 新增用户
- <http://127.0.0.1/user/update> `POST` 修改用户信息
- <http://127.0.0.1/user/delete> `GET/POST` 删除用户信息

### `RestFul` 用法

- <http://127.0.0.1/user/1> `GET`   根据用户 `id` 查询用户数据
- <http://127.0.0.1/user>  `POST`  新增用户
- <http://127.0.0.1/user>  `PUT`  修改用户信息
- <http://127.0.0.1/user>  `DELETE`  删除用户信息

## `RestFul` 中的请求方法有哪些

`get`、`post`、`put`、`delete`、`head`、`options`。

### `PUT`

`PUT` 方法在 `REST` 中主要用于更新资源。

`PUT` 请求通常带有资源的全部信息，表示该资源在服务器上的整体替换操作。

`PUT` 方法是幂等的：这意味着对于同一个资源，如果多次发出内容相同的 `PUT` 请求，其结果都是一致的。例如，如果你发送 `/user` 请求更新用户的 `name` 为 `steinsGate`，无论请求发出多少次，最终的 `name` 都是 `steinsGate`，不会产生其他副作用。

`PUT` 请求的数据通常放在请求的消息体中，类似于 `POST` 请求。与 `POST` 不同，`PUT` 是幂等的，因为它对同一资源重复执行多次操作，不会导致新的变化（只要数据一致）。

### `DELETE`

`DELETE` 方法在 `REST` 请求中主要用于删除资源。

`DELETE` 方法也是幂等的：无论删除同一个资源多少次，最终的结果都是该资源被删除。再次对已删除的资源发出 `DELETE` 请求，不会对服务器状态产生任何新的变化。

### `OPTIONS`

`options` 请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发`put`，`delete` 请求。

至于什么情况下浏览器会发预检请求，浏览器会会将请求分为两类，简单请求与非简单请求，非简单请求会产生预检 `options` 请求。

### `GET` 与 `POST`

---

#### 常见说法

- `GET` 使用 `URL` 或 `Cookie` 传参，而 `POST` 将数据放在消息体（`BODY`）中。
- `GET` 方式提交的数据有长度限制，而 `POST` 的数据可以非常大。
- `POST` 比 `GET` 更安全，因为数据不会在地址栏中显示。

虽然这些说法在某些场景下有一定的参考意义，但它们并不完全正确或全面。我们需要更深入地理解 `GET` 和 `POST` 的本质区别。

#### `GET` 与 `POST` 的实际区别

**1. 数据传递方式：**

- `GET` 请求一般用于从服务器获取资源。通常，参数会被包含在 `URL` 中，附加在请求的路径后（通过查询字符串的形式）。虽然 `HTTP` 协议允许 `GET` 请求有消息体，但大多数服务器和浏览器对消息体的支持有限或直接忽略，因此实际应用中 `GET` 请求的参数基本放在 `URL` 中。
- `POST` 请求用于向服务器发送数据，通常用于创建或更新资源。参数通常放在消息体（`BODY`）中，而不是 `URL` 中。这使得 `POST` 请求适合于发送较大的数据。

**2. 数据量限制：**

- `HTTP` 协议本身并没有对 `GET` 或 `POST` 的数据长度作出限制。`GET` 请求的长度限制主要来自于浏览器和服务器的实现，一些浏览器和服务器对 `URL` 长度有上限（例如，`IE` 对 `URL` 长度的限制为 `2083` 字节）。这通常是为了避免某些安全性和性能问题，如防止通过构造超长的 `URL` 来对服务器进行攻击。
- `POST` 请求则可以在消息体中携带大量数据，理论上没有限制，但实际中的大小限制则由服务器设置来控制。

**3. 安全性：**

- `GET` 请求的参数会被直接暴露在 `URL` 中，因此在浏览器历史记录、服务器日志或缓存中都有可能泄露。对于敏感数据，直接使用 `GET` 是不安全的。
- `POST` 请求的数据在消息体中传递，在地址栏中不可见，这减少了某些泄露风险。但这并不意味着 `POST` 天然比 `GET` 更安全。数据的安全性主要取决于传输协议。例如，在使用 `HTTPS` 时，无论是 `GET` 还是 `POST`，传输的数据都会被加密，因而两者在传输层面都是安全的。而在 `HTTP` 下，两者的传输内容都是明文，安全性较低。

**4. 幂等性：**

- `GET` 请求应当是幂等的：对同一资源多次执行相同的 `GET` 请求，不应该改变资源的状态。例如，多次访问同一个页面并不会改变它的内容。
- `POST` 请求通常不是幂等的：因为 `POST` 请求用于创建或更新资源，每次 `POST` 操作都可能改变服务器的状态。比如，向某个 `API POST` 数据可能会创建多个相同的资源，这与 `GET` 请求有本质上的区别。

#### 总结

- **GET** 用于从服务器获取数据，并且应当是幂等的。这意味着多次请求不会导致资源状态的变化。
- **POST** 用于向服务器发送数据，通常用于创建或修改资源。`POST` 请求不是幂等的，多次发送 `POST` 请求会对资源状态产生不同的影响。

因此，在设计 `API` 时，应当根据操作的性质选择合适的请求方法：如果是获取数据，使用 `GET`；如果是提交数据并创建资源，使用 `POST`。确保对幂等操作（如更新数据）使用正确的 `HTTP` 方法，例如 `PUT` 或 `DELETE`，而不是 `POST`。
