# Vite

## 依赖预构建

当你首次启动 `vite` 时，`Vite` 在本地加载你的站点之前预构建了项目依赖，`Vite`预编译之后，将文件缓存在`node_modules/.vite/`文件夹下。

### `CommonJS` 和 `UMD` 兼容性

在开发阶段中，`Vite` 的开发服务器将所有代码视为原生 `ES` 模块。因此，`Vite` 必须先将以 `CommonJS` 或 `UMD` 形式提供的依赖项转换为 `ES` 模块。

### 性能优化

- 为了提高后续页面的加载性能，`Vite`将那些具有许多内部模块的 `ESM` 依赖项转换为单个模块。

  - 如果不使用`esbuild`进行预构建，浏览器每检测到一个`import`语句就会向服务器发送一个请求，如果一个三方包被分割成很多的文件，这样就会发送很多请求，会触发浏览器并发请求限制。

- 默认只有 package.json 或者 lock 文件中的依赖发生变化时才会重新打包依赖

- 打包好的依赖在请求时会被浏览器进行强缓存，只有依赖发生变化或者强刷页面后才会重新请求

## 基于`ESM`的`Dev server`

传统的打包工具如`Webpack`是先解析依赖、打包构建再启动开发服务器，`Dev Server` 必须等待所有模块构建完成后才能启动，当我们修改了 `bundle` 模块中的一个子模块， 整个 `bundle` 文件都会重新打包然后输出。项目应用越大，启动时间越长。

`Vite`利用浏览器对`ESM`的支持，当 `import` 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件，本质上实现了动态加载。

## 基于`ESM`的`HMR`

::: tip 目前所有的打包工具实现热更新的思路都大同小异

主要是通过`WebSocket`创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。

:::

`Vite`的热更新：

- 开发服务器启动时，会在`index.html`中插入一段`JS`代码，用于创建一个`WebSocket`链接

- 通过`chokidar`对项目根目录进行监听，但是会忽略`node_modules`、`gitignore`等目录和文件
- 当文件发生变化时会根据文件类型进行不同的更新处理

  - `package.json` ：相当于更新了项目的第三方依赖，会重新进行依赖的预构建

  - `config或者env` ：配置信息变更直接重启开发服务器

  - 项目代码 ：根据项目代码的类型进行不同的处理

- `WebSocket`的服务端在处理完成文件更新之后，会把当前`HMR`的类型，文件的路径信息等返回给客户端
- 客户端根据`HMR`的类型进行不同的处理，对于普通文件的话直接走`ESM`的动态加载最终完成一次`HMR`

## `Vite` 核心原理

- `Vite`其核心原理是利用浏览器现在已经支持`ES6`的`import`，碰见`import`就会发送一个`HTTP`请求去加载文件。

- `Vite`启动一个 `koa` 服务器拦截这些请求，并在后端进行相应的处理，将项目中使用的文件通过简单的分解与整合，然后再以`ESM`格式返回给浏览器。

- `Vite`整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的`webpack`开发编译速度快出许多！

## `Vite` 的插件

- 基于`Rollup`的插件机制单独实现了一套`Vite`插件

- 所有的文件转换都在插件中实现，一个插件可以实现`Webpack`中`loader`和`plugin`的效果

- `Vite`默认内置一些插件，可以通过插件的`enforce`配置来强制设置插件调用顺序（在内置前或者后执行）

  - `pre` ：在 `Vite` 核心插件之前调用该插件
  - 默认 ：在 `Vite` 核心插件之后调用该插件
  - `post` ：在 `Vite` 构建插件之后调用该插件

- 通过`apply`配置可以设置插件在开发或生产阶段调用

- 每一个插件将返回一个对象，包含一个`name`字段，用于表示插件的名称，其他的插件钩子函数用于执行插件的逻辑

::: info 相关资料

- [<u>Vite 官方中文文档</u>](https://cn.vitejs.dev/)

- [<u>Vite | Github</u>](https://github.com/vitejs/vite)

:::
