import{_ as a,o as e,c as o,N as n}from"./chunks/framework.2673bc46.js";const y=JSON.parse('{"title":"Hooks 相关知识","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/base/hooks.md","lastUpdated":1727500876000}'),l={name:"frame/react/base/hooks.md"};function c(t,s,p,r,d,i){return e(),o("div",null,s[0]||(s[0]=[n(`<h1 id="hooks-相关知识" tabindex="-1">Hooks 相关知识 <a class="header-anchor" href="#hooks-相关知识" aria-label="Permalink to &quot;Hooks 相关知识&quot;">​</a></h1><h2 id="hooks-要遵守的规则" tabindex="-1"><code>Hooks</code> 要遵守的规则 <a class="header-anchor" href="#hooks-要遵守的规则" aria-label="Permalink to &quot;\`Hooks\` 要遵守的规则&quot;">​</a></h2><ul><li>只在函数最顶层调用 <code>Hooks</code></li></ul><p>不要在循环、条件或嵌套函数中调用 <code>Hooks</code>。确保每次组件渲染时 <code>Hooks</code> 的调用顺序一致。这是因为 <code>React</code> 依赖于 <code>Hooks</code> 的调用顺序来管理组件的内部状态</p><ul><li>只在 <code>React</code> 函数组件中调用 <code>Hooks</code></li></ul><p>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hooks</code>。<code>Hooks</code> 只能在 <code>React</code> 的函数组件或自定义的 <code>Hook（函数名以</code> <code>use</code> 开头）中调用</p><h2 id="setstate-是同步还是异步" tabindex="-1">setState 是同步还是异步 <a class="header-anchor" href="#setstate-是同步还是异步" aria-label="Permalink to &quot;setState 是同步还是异步&quot;">​</a></h2><p><code>setState</code> 在类组件中是 <code>this.setState</code> 方法，在函数组件中是 <code>useState</code> 返回值的修改函数 <code>setState</code> 用于变更状态，触发组件重新渲染，更新视图 <code>UI</code></p><ul><li>关于<code>useState</code>的实现可以看这里 <a href="/rsource/react/useState"><u>React 18.2 | useState 实现 🚀</u></a></li></ul><h3 id="在-react-18-之前" tabindex="-1">在 <code>React 18</code> 之前 <a class="header-anchor" href="#在-react-18-之前" aria-label="Permalink to &quot;在 \`React 18\` 之前&quot;">​</a></h3><p>在 <code>React 18</code> 之前，只要在 <code>React</code> 可以控制的地方，<code>setState</code> 的执行都是异步的，比如在 <code>React</code> 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略</p><p>而在 <code>React</code> 无法控制的地方，如监听原生事件和异步调用的地方，<code>setState</code> 的执行都是就是同步的。比如在 <code>addEventListener</code>、<code>setTimeout</code>、<code>Promise</code> 等的回调函数中</p><h3 id="在-react-18-之后" tabindex="-1">在 <code>React 18</code> 之后 <a class="header-anchor" href="#在-react-18-之后" aria-label="Permalink to &quot;在 \`React 18\` 之后&quot;">​</a></h3><p>在 <code>concurrent</code> 模式下，由于默认启用了并发更新，所以 <code>setState</code> 的执行都是异步的，即不管是在 <code>React</code> 可以控制的地方还是无法控制的地方，默认都会走合并操作，延迟更新的策略</p><div class="tip custom-block"><p class="custom-block-title"><code>setState</code> 为什么是异步的？</p><ul><li>性能优化、减少渲染次数</li></ul><p>从源码的角度分析，在执行任务调度之前，回去判断当前正在更新的 lane 优先级和老的更新优先级做对比，如果优先级一样就开启了批处理，就不需要再次调度新任务执行更新了。（源码地址 <a href="https://github.com/azzlzzxz/react-v18.2.0/blob/75de845d69876d84a4a8b226c5f2e6203328b8ee/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L715" target="_blank" rel="noreferrer"><u>批处理</u></a>）</p><ul><li>保持内部一致性</li></ul></div><h2 id="闭包陷阱" tabindex="-1">闭包陷阱 <a class="header-anchor" href="#闭包陷阱" aria-label="Permalink to &quot;闭包陷阱&quot;">​</a></h2><p>闭包陷阱就是 <code>effect</code> 函数等引用了 <code>state</code>，形成了闭包，但是并没有把 <code>state</code> 加到依赖数组里，导致执行 <code>effect</code> 时用的 <code>state</code> 还是之前的。</p><blockquote><p>举个 🌰</p></blockquote><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">useEffect</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">useState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setInterval</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">count</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setCount</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#BABED8;"> App</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/react/hook_trap.gif" alt="hook_trap"></p><p>可以看到，<code>setCount</code> 时拿到的 <code>count</code> 一直是 <code>0</code></p><p>解决方案：</p><ul><li><p>使用 <code>setState</code> 的函数的形式，从参数拿到上次的 <code>state</code>，这样就不会形成闭包了，或者用 <code>useReducer</code>，直接 <code>dispatch action</code>，而不是直接操作 <code>state</code>，这样也不会形成闭包</p></li><li><p>把用到的 <code>state</code> 加到依赖数组里，这样 <code>state</code> 变了就会重新跑 <code>effect</code> 函数，引用新的 <code>state</code></p></li><li><p>使用 <code>useRef</code> 保存每次渲染的值，用到的时候从 <code>ref.current</code> 取</p></li></ul>`,23)]))}const u=a(l,[["render",c]]);export{y as __pageData,u as default};
