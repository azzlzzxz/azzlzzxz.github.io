import{_ as r,B as a,o as t,c as i,N as o,x as c,D as l,z as s,a as n}from"./chunks/framework.87264d68.js";const x=JSON.parse('{"title":"介绍 Fiber","description":"","frontmatter":{},"headers":[],"relativePath":"rsource/react/introduce.md","lastUpdated":1726501491000}'),p={name:"rsource/react/introduce.md"};function b(u,e,f,m,F,h){const d=a("font");return t(),i("div",null,[e[1]||(e[1]=o('<h1 id="介绍-fiber" tabindex="-1">介绍 Fiber <a class="header-anchor" href="#介绍-fiber" aria-label="Permalink to &quot;介绍 Fiber&quot;">​</a></h1><h2 id="为什么要有fiber" tabindex="-1">为什么要有<code>Fiber</code>？ <a class="header-anchor" href="#为什么要有fiber" aria-label="Permalink to &quot;为什么要有`Fiber`？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">前置知识</p><ul><li><code>JavaScript</code>是单线程的，而浏览器是多进程的（每个进程有可能包含多个线程）</li></ul><p>浏览器是多进程的，其中的渲染进程要处理包括 <code>事件系统</code>、<code>定时器/延时器</code>、<code>网络请求</code>、<code>GUI 渲染线程</code>（<code>GUI</code> 负责页面的布局和绘制） 等各种线程任务，而<code>JavaScript</code>的线程是可以操作<code>DOM</code>的，这就使得<code>JavaScript</code>线程和浏览器的<code>GUI 渲染线程</code>存在互斥的问题。</p><p>如果 <code>GUI 渲染线程</code> 和 <code>JavaScript</code> 线程同时工作，会导致页面的渲染难以预测，例如：染线程刚绘制好的一段文字，<code>JavaScript</code> 线程可能会将其修改为其他文字，这样页面可能会渲染混乱、样式错乱、甚至导致页面崩溃</p><ul><li><code>JavaScript</code> 线程会阻塞浏览器渲染</li></ul><p>当下主流浏览器的刷新频率为 60Hz，即每 16.6ms（1000ms / 60Hz）浏览器就会刷新一次，而在这 16.6ms 内，需要执行<code>JavaScript</code> 脚本、渲染线程也会执行，同时在互斥的机制下，如果 <code>JavaScript</code> 长时间的占据主线程，就会导致 <strong>渲染层面的更新就不得不长时间地等待，界面长时间不更新，带给用户的体验就是所谓的“卡顿”</strong>。</p></div><p>在 <code>React 16</code> 之前，<code>React</code> 使用的是基于 <code>栈递归</code> 的协调算法，这种算法会在一次渲染过程中递归遍历整个组件树，并且<code>不会被打断</code>，这种递归的方式会带来性能上的瓶颈，尤其是在组件树很大时，渲染时间就会变长，导致浏览器出现卡顿。</p><p><code>Fiber</code> 是 <code>React 16</code> 引入的一种新的协调算法，用于解决 <code>React</code> 在复杂 <code>UI</code> 渲染时的性能问题。</p>',5)),c("p",null,[c("strong",null,[l(d,{color:"FF9D00"},{default:s(()=>e[0]||(e[0]=[n("将递归的无法中断的更新重构为异步的可中断更新")])),_:1})])]),e[2]||(e[2]=o('<h2 id="什么是-fiber" tabindex="-1">什么是 <code>Fiber</code>？ <a class="header-anchor" href="#什么是-fiber" aria-label="Permalink to &quot;什么是 `Fiber`？&quot;">​</a></h2><ul><li><code>Fiber</code> 作为架构</li></ul><p>在旧的架构中，<code>Reconciler（协调器）</code> 采用递归的方式执行，无法中断，节点数据保存在递归的调用栈中，被称为 <code>stack reconciler</code>。</p><p>在新的架构中，<code>Reconciler</code> 是基于 <code>Fiber</code> 实现的，节点数据保存在 <code>Fiber</code> 中，被称为 <code>Fiber reconciler</code>。</p><ul><li><code>Fiber</code> 作为静态数据结构</li></ul><p>每个<code>Fiber 节点</code> 对应一个 <code>React.element</code>，保存了该组件的类型<code>（函数组件 / 类组件 / 原生组件）</code>、对应的<code>DOM</code>节点等信息。</p><ul><li><code>Fiber</code> 作为动态工作单元</li></ul><p><code>Fiber</code> 保存着节点的动态信息，包括本次更新中改变的状态、节点更新信息、节点更新优先级、副作用标签等。</p><h2 id="fiber-的作用" tabindex="-1"><code>Fiber</code> 的作用 <a class="header-anchor" href="#fiber-的作用" aria-label="Permalink to &quot;`Fiber` 的作用&quot;">​</a></h2>',9))])}const S=r(p,[["render",b]]);export{x as __pageData,S as default};
