import{_ as s,B as t,o as n,c as i,N as r,x as e,D as d,z as l,a as o}from"./chunks/framework.72e0000c.js";const k=JSON.parse('{"title":"浏览器缓存机制","description":"","frontmatter":{},"headers":[],"relativePath":"base/browser/cache.md","lastUpdated":1726377612000}'),p={name:"base/browser/cache.md"};function h(u,a,m,f,b,g){const c=t("font");return n(),i("div",null,[a[3]||(a[3]=r('<h1 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h1><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/cache.jpg" alt="cache"></p><h2 id="介绍一下浏览器缓存位置和优先级" tabindex="-1">介绍一下浏览器缓存位置和优先级 <a class="header-anchor" href="#介绍一下浏览器缓存位置和优先级" aria-label="Permalink to &quot;介绍一下浏览器缓存位置和优先级&quot;">​</a></h2><ol><li><code>Service Worker</code></li><li><code>Memory Cache</code>（内存缓存）</li><li><code>Disk Cache</code>（硬盘缓存）</li><li><code>Push Cache</code>（推送缓存）</li><li>以上缓存都没命中就会进行网络请求</li></ol><h2 id="不同缓存间的差别" tabindex="-1">不同缓存间的差别 <a class="header-anchor" href="#不同缓存间的差别" aria-label="Permalink to &quot;不同缓存间的差别&quot;">​</a></h2><h3 id="service-worker" tabindex="-1"><code>Service Worker</code> <a class="header-anchor" href="#service-worker" aria-label="Permalink to &quot;`Service Worker`&quot;">​</a></h3><p>和 <code>Web Worker</code> 类似，是独立的线程，我们可以在这个线程中缓存文件，在主线程需要的时候读取这里的文件，<code>Service Worker</code> 使我们可以自由选择缓存哪些文件以及文件的匹配、读取规则，并且缓存是持续性的。</p><p><code>ServiceWorker</code> 是运行在浏览器后台进程里的一段 <code>JS</code>，它可以做许多事情，比如拦截客户端的请求、向客户端发送消息、向服务器发起请求等等，其中最重要的作用之一就是离线资源缓存。</p><p><code>ServiceWorker</code> 拥有对缓存流程丰富灵活的控制能力，当页面请求到 <code>ServiceWorker</code> 时，<code>ServiceWorker</code> 同时请求缓存和网络，把缓存的内容直接给用户，而后覆盖缓存。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/server_worker.png" alt="server_worker"></p><p><strong>注意：需要<code>HTTPS</code>才可以使用<code> ServiceWorker</code></strong></p><h3 id="memory-cache" tabindex="-1"><code>Memory Cache</code> <a class="header-anchor" href="#memory-cache" aria-label="Permalink to &quot;`Memory Cache`&quot;">​</a></h3><p>即内存缓存，内存缓存不是持续性的，缓存会随着进程释放而释放。</p><p>内存缓存：读取快、持续时间短、容量小。</p><h3 id="disk-cache" tabindex="-1"><code>Disk Cache</code> <a class="header-anchor" href="#disk-cache" aria-label="Permalink to &quot;`Disk Cache`&quot;">​</a></h3><p>即硬盘缓存，相较于内存缓存，硬盘缓存的持续性和容量更优，它会根据 <code>HTTP header</code> 的字段判断哪些资源需要缓存。</p><p>硬盘缓存：读取慢、持续时间长、容量大。</p><h3 id="push-cache" tabindex="-1"><code>Push Cache</code> <a class="header-anchor" href="#push-cache" aria-label="Permalink to &quot;`Push Cache`&quot;">​</a></h3><p>即推送缓存，是 <code>HTTP/2</code> 的内容，目前应用较少。</p><h2 id="浏览器缓存策略" tabindex="-1">浏览器缓存策略 <a class="header-anchor" href="#浏览器缓存策略" aria-label="Permalink to &quot;浏览器缓存策略&quot;">​</a></h2><p><code>HTTP</code> 缓存一般分为两类：强缓存（也称本地缓存）  和   协商缓存（也称 304 缓存）。</p><p>普通刷新会启用协商缓存，忽略强缓存。只有在地址栏或收藏夹输入网址、通过链接引用资源等情况下，浏览器才会启用强缓存。</p><p>强缓存(不要向服务器询问的缓存)（200）</p><p>本地缓存是最快速的一种缓存方式，只要资源还在缓存有效期内，浏览器就会直接在本地读取，不会请求服务端。</p><p><code>from disk cache</code> 和 <code>from memory cache</code> 吗，什么时候会触发？</p><ol><li>先查找内存，如果内存中存在，从内存中加载；</li><li>如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；</li><li>如果硬盘中未查找到，那就进行网络请求；</li><li>加载到的资源缓存到硬盘和内存；</li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/memory_cache.png" alt="memory_cache"></p><h3 id="设置-expires-http1-0" tabindex="-1">设置 <code>Expires(HTTP1.0)</code> <a class="header-anchor" href="#设置-expires-http1-0" aria-label="Permalink to &quot;设置 `Expires(HTTP1.0)`&quot;">​</a></h3><p>即过期时间，例如<code>「Expires: Thu, 26 Dec 2019 10:30:42 GMT」</code>表示缓存会在这个时间后失效，这个过期日期是绝对日期，如果修改了本地日期，或者本地日期与服务器日期不一致，那么将导致缓存过期时间错误。</p><p><code>Expires </code>是 <code>HTTP1.0</code> 的产物，故现在大多数使用 <code>Cache-Control</code> 替代。</p><h3 id="设置-cache-control" tabindex="-1">设置 <code>Cache-Control</code> <a class="header-anchor" href="#设置-cache-control" aria-label="Permalink to &quot;设置 `Cache-Control`&quot;">​</a></h3><p><code>HTTP/1.1 </code>新增字段，<code>Cache-Control</code> 可以通过 <code>max-age</code> 字段来设置过期时间，例如<code>「Cache-Control:max-age=3600」</code>除此之外<code>Cache-Control</code>还能设置<code>private/no-cache</code>等多种字段:</p><ul><li><code>private：</code>客户端可以缓存</li><li><code>public：</code>客户端和代理服务器都可以缓存</li><li><code>max-age=t：</code>缓存内容将在<code>t</code>秒后失效</li><li><code>no-cache：</code>需要使用协商缓存来验证缓存数据</li><li><code>no-store：</code>所有内容都不会缓存。</li></ul>',33)),e("p",null,[e("strong",null,[d(c,{color:"#FF4229"},{default:l(()=>a[0]||(a[0]=[o("请注意"),e("code",null,"no-cache",-1),o("指令很多人误以为是不缓存，这是不准确的，"),e("code",null,"no-cache",-1),o(" 的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。"),e("br",null,null,-1)])),_:1})])]),e("p",null,[e("strong",null,[d(c,{color:"#FF9D00"},{default:l(()=>a[1]||(a[1]=[e("code",null,"no-store",-1),o("才是不缓存内容。当在首部字段"),e("code",null,"Cache-Control",-1),o("有指定"),e("code",null,"max-age",-1),o("指令时，比起首部字段 "),e("code",null,"Expires",-1),o("，会优先处理"),e("code",null,"max-age",-1),o("指令。命中强缓存的表现形式："),e("code",null,"Firefox ",-1),o("浏览器表现为一个灰色的 200 状态码。"),e("code",null,"Chrome ",-1),o("浏览器状态码表现为"),e("code",null," 200 (from disk cache)",-1),o("或是"),e("code",null," 200 OK (from memory cache)",-1)])),_:1})])]),a[4]||(a[4]=r('<h3 id="协商缓存-需要向服务器询问缓存是否已经过期-304" tabindex="-1">协商缓存(需要向服务器询问缓存是否已经过期)（304） <a class="header-anchor" href="#协商缓存-需要向服务器询问缓存是否已经过期-304" aria-label="Permalink to &quot;协商缓存(需要向服务器询问缓存是否已经过期)（304）&quot;">​</a></h3><p>协商缓存，顾名思义是经过浏览器与服务器之间协商过之后，在决定是否读取本地缓存，如果服务器通知浏览器可以读取本地缓存，会返回 304 状态码，并且协商过程很简单，只会发送头信息，不会发送响应体</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/304.png" alt="304"></p><h4 id="last-modified-http1-0" tabindex="-1"><code>Last-Modified(HTTP1.0)</code> <a class="header-anchor" href="#last-modified-http1-0" aria-label="Permalink to &quot;`Last-Modified(HTTP1.0)`&quot;">​</a></h4><p>即最后修改时间，浏览器第一次请求资源时，服务器会在响应头上加上<code>Last-Modified</code>。</p><p>当浏览器再次请求该资源时，浏览器会在请求头中带上<code>If-Modified-Since</code>字段，字段的值就是之前服务器返回的最后修改时间，服务器对比这两个时间，若相同则返回 304，否则返回新资源，并更新<code> Last-Modified</code></p><h4 id="etag" tabindex="-1"><code>ETag</code> <a class="header-anchor" href="#etag" aria-label="Permalink to &quot;`ETag`&quot;">​</a></h4><p><code>HTTP/1.1 </code>新增字段，表示文件唯一标识，只要文件内容改动，<code>ETag </code>就会重新计算。</p><p>缓存流程和<code>Last-Modified</code>一样：服务器发送<code>ETag</code>字段 -&gt; 浏览器再次请求时发送<code>If-None-Match</code>-&gt; 如果<code>ETag</code>值不匹配，说明文件已经改变，返回新资源并更新<code> ETag</code>，若匹配则返回 304。</p><ul><li><p><code>If-Match：</code>条件请求，携带上一次请求中资源的<code> ETag</code>，服务器根据这个字段判断文件是否有新的修改。</p></li><li><p><code>If-None-Match： </code>再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 。</p></li></ul><p><code>If-None-Match </code>则与被请求资源的唯一标识进行对比。</p><ul><li>不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。</li><li>相同，说明资源无心修改，则响应<code> header</code>，浏览器直接从缓存中获取数据信息。返回状态码 304.</li></ul><p>但是实际应用中由于<code>Etag</code>的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用<code> Etag</code> 了。</p><p>两者对比：</p><ul><li><p><code>ETag </code>比<code>Last-Modified</code>更准确：如果我们打开文件但并没有修改，<code>Last-Modified</code> 也会改变，并且<code>Last-Modified</code>的单位时间为一秒，如果一秒内修改完了文件，那么还是会命中缓存。</p></li><li><p>如果什么缓存策略都没有设置，那么浏览器会取响应头中的<code>Date</code>减去<code>Last-Modified</code>值的 10% 作为缓存时间。</p></li></ul><h2 id="缓存场景" tabindex="-1">缓存场景 <a class="header-anchor" href="#缓存场景" aria-label="Permalink to &quot;缓存场景&quot;">​</a></h2><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略。</p><p>对于某些不需要缓存的资源，可以使用<code>Cache-control: no-store</code>，表示该资源不需要缓存</p><p>对于频繁变动的资源，可以使用<code>Cache-Control: no-cache</code>并配合<code>ETag</code>使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</p><p>对于代码文件来说，通常使用<code>Cache-Control: max-age=31536000</code>并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</p><h2 id="启发式缓存" tabindex="-1">启发式缓存 <a class="header-anchor" href="#启发式缓存" aria-label="Permalink to &quot;启发式缓存&quot;">​</a></h2><p>如果响应中未显示<code> Expires</code>，<code>Cache-Control：max-age </code>或<code> Cache-Control：s-maxage</code>，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算新鲜度寿命。</p><p>通常会根据响应头中的 2 个时间字段<code>Date</code>减去<code>Last-Modified</code>值的 10% 作为缓存时间。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// Date 减去 Last-Modified 值的 10% 作为缓存时间。</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间</span></span>\n<span class="line"><span style="color:#BABED8;">response_is_fresh </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;">  </span><span style="color:#82AAFF;">max</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;">（Date </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">  Last</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Modified)) </span><span style="color:#89DDFF;">%</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">10</span></span>\n<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',24)),e("p",null,[e("strong",null,[d(c,{color:"FF9D00"},{default:l(()=>a[2]||(a[2]=[o("注：只有在服务端没有返回明确的缓存策略时才会激活浏览器的启发式缓存策略。")])),_:1})])]),a[5]||(a[5]=e("h3",{id:"启发式缓存会引起什么问题",tabindex:"-1"},[o("启发式缓存会引起什么问题 "),e("a",{class:"header-anchor",href:"#启发式缓存会引起什么问题","aria-label":'Permalink to "启发式缓存会引起什么问题"'},"​")],-1)),a[6]||(a[6]=e("p",null,[o("考虑一个情况，假设你有一个文件没有设置缓存时间，在一个月前你更新了上个版本。这次发版后，你可能得等到 3 天后用户才看到新的内容了。如果这个资源还在"),e("code",null,"CDN"),o("也缓存了，则问题会更严重。")],-1)),a[7]||(a[7]=e("p",null,[o("所以，要给资源设置合理的缓存时间。不要不设置缓存，也不要设置过长时间的缓存。强缓存时间过长，则内容要很久才会覆盖新版本，缓存时间过短，服务器可能背不住。一般带"),e("code",null,"hash"),o("的文件缓存时间可以长一点。")],-1))])}const x=s(p,[["render",h]]);export{k as __pageData,x as default};
