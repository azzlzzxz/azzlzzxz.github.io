import{_ as r,B as i,o as T,c as s,x as t,D as a,z as o,a as l,Q as n}from"./chunks/framework.a5035e6c.js";const _="/assets/http2.2a937e09.png",c="/assets/header_zip.07c96157.png",w=JSON.parse('{"title":"Http 协议","description":"","frontmatter":{},"headers":[],"relativePath":"base/network/httpAgreement.md","lastUpdated":1697167141000}'),u={name:"base/network/httpAgreement.md"},p=n('<h1 id="http-协议" tabindex="-1">Http 协议 <a class="header-anchor" href="#http-协议" aria-label="Permalink to &quot;Http 协议&quot;">​</a></h1><h2 id="http-0-9-单行协议" tabindex="-1">HTTP/0.9 - 单行协议 <a class="header-anchor" href="#http-0-9-单行协议" aria-label="Permalink to &quot;HTTP/0.9 - 单行协议&quot;">​</a></h2><p>HTTP 于 1990 年问世，那时候 HTTP 非常简单：只支持 GET 方法；没有首部；只能获取纯文本。</p><h2 id="http-1-0-搭建协议的框架" tabindex="-1">HTTP/1.0 - 搭建协议的框架 <a class="header-anchor" href="#http-1-0-搭建协议的框架" aria-label="Permalink to &quot;HTTP/1.0 - 搭建协议的框架&quot;">​</a></h2><p>1996 年，HTTP 正式被作为标准公布，版本为 HTTP/1.0。1.0 版本增加了首部、状态码、权限、缓存、长连接（默认短连接）等规范，可以说搭建了协议的基本框架。</p><p>缺陷：无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手。</p><h2 id="http-1-1-进一步完善" tabindex="-1">HTTP/1.1 - 进一步完善 <a class="header-anchor" href="#http-1-1-进一步完善" aria-label="Permalink to &quot;HTTP/1.1 - 进一步完善&quot;">​</a></h2><p>1997 年，1.1 版本接踵而至。1.1 版本的重大改进在于默认长连接；强制客户端提供 Host 首部；管线化；Cache-Control、ETag 等缓存的相关扩展。</p><h3 id="http-1-1-存在有哪些问题" tabindex="-1">HTTP/1.1 存在有哪些问题： <a class="header-anchor" href="#http-1-1-存在有哪些问题" aria-label="Permalink to &quot;HTTP/1.1 存在有哪些问题：&quot;">​</a></h3>',9),h=t("p",null,"线头阻塞：TCP 连接上只能发送一个请求，前面的请求未完成前，后续的请求都在排队等待。 针对队头阻塞,人们尝试过以下办法来解决：",-1),d=t("p",null,"精灵图，Spriting 合并多张小图为一张大图,再用 JavaScript 或者 CSS 将小图重新“切割”出来的技术。",-1),P=t("p",null,"拼接(Concatenation)将多个体积较小的 JavaScript 使用 webpack 等工具打包成 1 个体积更大的 JavaScript 文件,但如果其中 1 个文件的改动就会导致大量数据被重新下载多个文件。",-1),H=t("li",null,[t("p",null,"多个 TCP 连接")],-1),f=t("p",null,"虽然 HTTP/1.1 管线化可以支持请求并发，所以 1.1 版本请求并发依赖于多个 TCP 连接，建立 TCP 连接成本很高，还会存在慢启动的问题。",-1),m=t("ol",{start:"3"},[t("li",null,"头部冗余，采用文本格式")],-1),F={start:"4"},C=t("li",null,"客户端需要主动请求",-1),S=t("h2",{id:"http-2",tabindex:"-1"},[l("HTTP/2 "),t("a",{class:"header-anchor",href:"#http-2","aria-label":'Permalink to "HTTP/2"'},"​")],-1),b=t("p",null,"HTTP/2 由两个规范（Specification）组成：",-1),g=t("ul",null,[t("li",null,"Hypertext Transfer Protocol version 2 - RFC7540"),t("li",null,"HPACK - Header Compression for HTTP/2 - RFC7541")],-1),D=n('<h3 id="二进制分帧层" tabindex="-1">二进制分帧层 <a class="header-anchor" href="#二进制分帧层" aria-label="Permalink to &quot;二进制分帧层&quot;">​</a></h3><p>HTTP/2 是二进制协议，他采用二进制格式传输数据而不是 1.x 的文本格式。</p><p><img src="'+_+'" alt="http2"></p><p>👆 的图中很清晰的表达了 HTTP/1.1 的响应和 2.0 的区别。 1.1 响应是文本格式，而 2.0 把响应划分成了两个帧，图中的 HEADERS（首部）和 DATA（消息负载） 是帧的类型。也就是说一条 HTTP 响应，划分成了两个帧来传输，并且采用二进制来编码。</p><p>这里我们来提三个概念。</p><ul><li>流（Stream）：已建立的 TCP 连接上的双向字节流，可以承载一个或多个消息。</li><li>消息（Message）：一个完整的 HTTP 请求或响应，由一个或多个帧组成。特定消息的帧在同一个流上发送，这意味着一个 HTTP 请求或响应只能在一个流上发送。</li><li>帧（Frame）：通信的基本单位。</li></ul><p>一个 TCP 连接上可以有任意数量的流。</p><h3 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h3><p>在 1.x 版本中，首部用文本格式传输，通常会给每个传输增加 500-800 字节的开销。现在打开一个网页上百个请求已是常态，而每个请求带的一些首部字段都是相同的，例如 cookie、user-agent 等。</p>',9),x=n('<ul><li>维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合。</li><li>维护一份相同的动态字典，可以动态的添加内容。</li><li>通过静态 Huffman 编码对传输的首部字段进行编码。</li></ul><p>HTTP2 的静态字典是长这个样子的（只截取了部分）：</p><p><img src="'+c+'" alt="header_zip"></p><p>所以我们在传输首部字段的时候，例如要传输 method:GET,那我们只需要传输静态字典里面 method:GET 对应的索引值就可以了，一个字节搞定。</p><p>像 user-agent、cookie 这种静态字典里面只有首部名称而没有值的首部，第一次传输需要 user-agent 在静态字典中的索引以及他的值，值会采用静态 Huffman 编码来减小体积。</p><p>第一次传输过 user-agent 之后呢，浏览器和服务器端就会把它添加到自己的动态字典中。后续传输就可以传输索引了，一个字节搞定。</p><h3 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to &quot;多路复用&quot;">​</a></h3><p>在 HTTP/2 中:</p>',8),k=t("p",null,"这一特性，使性能有了极大提升：",-1),A=t("ul",null,[t("li",null,"同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。"),t("li",null,"并行交错地发送多个请求/响应，请求/响应之间互不影响。"),t("li",null,"在 HTTP/2 中，每个请求都可以带一个 31bit 的优先值，0 表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。")],-1);function q(E,V,v,N,I,R){const e=i("font");return T(),s("div",null,[p,t("ol",null,[t("li",null,[h,t("ul",null,[t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("同一页面的资源分散到不同域名下，提升连接上限。")]),_:1}),a(e,{color:"FF9D00"},{default:o(()=>[l("Chrome 有个机制，对于同一个域名，默认允许同时建立 6 个 TCP 持久连接")]),_:1}),l("，使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成（chrome 放弃了）")]),t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("合并小文件减少资源数。")]),_:1}),d]),t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("内联(Inlining)资源是另外一种防止发送很多小图请求的技巧")]),_:1}),l("，将图片的原始数据嵌入在 CSS 文件里面的 URL 里，减少网络请求次数。")]),t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("减少请求数量。")]),_:1}),P])])]),H]),f,m,t("ul",null,[t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("HTTP/1.x 版本是采用文本格式，首部未压缩，")]),_:1}),l("而且每一个请求都会带上 cookie、user-agent 等完全相同的首部。")]),t("li",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("无状态是指协议对于连接状态没有记忆能力。")]),_:1}),l("纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。")]),t("li",null,[l('由于报文 Header 一般会携带"User Agent"、"Cookie"、"Accept"、"Server"等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成了不折不扣的“大头儿子”。'),a(e,{color:"FF9D00"},{default:o(()=>[l("Header 里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，请求响应报文里有大量字段值都是重复的，非常浪费。")]),_:1})])]),t("ol",F,[C,t("li",null,[l("HTTP/1.1 在传输数据时，所有传输的"),a(e,{color:"FF9D00"},{default:o(()=>[l("内容都是明文")]),_:1}),l("内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。")])]),S,t("p",null,[l("2015 年，HTTP/2 发布。HTTP/2 是现行 HTTP 协议（HTTP/1.x）的替代，但它不是重写，HTTP 方法/状态码/语义都与 HTTP/1.x 一样。 HTTP/2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection） 。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署，"),a(e,{color:"FF9D00"},{default:o(()=>[l("使用 HTTP/2 能带来 20%~60%的效率提升。")]),_:1})]),b,g,t("p",null,[t("strong",null,[a(e,{color:"FF4229"},{default:o(()=>[l("HTTP/2 传输数据量的大幅减少,主要有两个原因:以二进制方式传输和 Header 压缩。")]),_:1})])]),D,a(e,{color:"FF9D00"},{default:o(()=>[l("HTTP/2 为此采用 HPACK 压缩格式来压缩首部。头部压缩需要在浏览器和服务器端之间：")]),_:1}),x,t("ul",null,[t("li",null,[t("strong",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("同域名下所有通信都在单个连接上完成。")]),_:1})])]),t("li",null,[t("strong",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("单个连接可以承载任意数量的双向数据流。")]),_:1})])]),t("li",null,[t("strong",null,[a(e,{color:"FF9D00"},{default:o(()=>[l("数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。")]),_:1})])])]),k,A])}const G=r(u,[["render",q]]);export{w as __pageData,G as default};
