import{_ as o,o as c,c as d,N as a}from"./chunks/framework.5873b8fd.js";const C=JSON.parse('{"title":"OSI & TCP","description":"","frontmatter":{},"headers":[],"relativePath":"base/network/tcp.md","lastUpdated":1727424100000}'),t={name:"base/network/tcp.md"};function i(l,e,p,s,r,n){return c(),d("div",null,e[0]||(e[0]=[a('<h1 id="osi-tcp" tabindex="-1">OSI &amp; TCP <a class="header-anchor" href="#osi-tcp" aria-label="Permalink to &quot;OSI &amp; TCP&quot;">​</a></h1><p><code>OSI</code> 分层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/osi_seven.png" alt="osi_seven"></p><p><code>TCP/IP</code> 模型：应用层、传输层、网络层、网络接口层。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/tcp.png" alt="tcp"></p><p>应用层协议(常用)：<code>HTTP</code>、<code>RTSP</code>、<code>FTP</code>。</p><p>传输层协议：<code>TCP</code>、<code>UDP</code>。</p><h2 id="osi-的七层模型具体是什么" tabindex="-1"><code>OSI</code> 的七层模型具体是什么 <a class="header-anchor" href="#osi-的七层模型具体是什么" aria-label="Permalink to &quot;`OSI` 的七层模型具体是什么&quot;">​</a></h2><p><code>ISO</code> 于 1978 年开发的一套标准架构 <code>ISO</code> 模型，被引用来说明数据通信协议的结构和功能。</p><p><code>OSI</code> 在功能上可以划分为两组：</p><ul><li>网络群组：物理层、数据链路层、网络层</li><li>使用者群组：传输层、会话层、表示层、应用层</li></ul><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/OSI.png" alt="OSI"></p><p>其中高层（7、6、5、4 层）定义了应用程序的功能，下面三层（3、2、1 层）主要面向通过网络的端到端的数据流。</p><h2 id="tcp-ip" tabindex="-1"><code>TCP / IP</code> <a class="header-anchor" href="#tcp-ip" aria-label="Permalink to &quot;`TCP / IP`&quot;">​</a></h2><p><code>TCP/IP</code> 传输协议，即传输控制/网络协议，也叫作网络通讯协议。 它是在网络的使用中的最基本的通信协议。 <code>TCP/IP</code> 传输协议对互联网中各部分进行通信的标准和方法进行了规定。 并且，<code>TCP/IP</code> 传输协议是保证网络数据信息及时、完整传输的两个重要的协议。</p><h3 id="tcp-ip-如何保证数据包传输的有序可靠" tabindex="-1"><code>TCP/IP</code> 如何保证数据包传输的有序可靠 <a class="header-anchor" href="#tcp-ip-如何保证数据包传输的有序可靠" aria-label="Permalink to &quot;`TCP/IP` 如何保证数据包传输的有序可靠&quot;">​</a></h3><p>对字节流分段并进行编号然后通过 <code>ACK</code> 回复和超时重发这两个机制来保证。</p><ol><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区。</li><li>并为每个已发送的数据包启动一个超时定时器。</li><li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区。</li><li>否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</li><li>接收方收到数据包后，先进行 <code>CRC</code> 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</li></ol><h3 id="tcp-三次握手-四次挥手" tabindex="-1"><code>TCP</code> 三次握手&amp;四次挥手 <a class="header-anchor" href="#tcp-三次握手-四次挥手" aria-label="Permalink to &quot;`TCP` 三次握手&amp;四次挥手&quot;">​</a></h3><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/tcp_3_4.jpg" alt="tcp_3_4"></p><h4 id="_3-次握手" tabindex="-1"><strong>3 次握手</strong> <a class="header-anchor" href="#_3-次握手" aria-label="Permalink to &quot;**3 次握手**&quot;">​</a></h4><ul><li><p>第一次握手：建立连接时，客户端发送 <code>syn</code> 包<code>（syn=x）</code>到服务器，并进入 <code>SYN_SENT</code> 状态，等待服务器确认；<code>SYN</code>：同步序列编号<code>（Synchronize Sequence Numbers）</code>。</p></li><li><p>第二次握手：服务器收到 <code>syn</code> 包并确认客户的 <code>SYN（ack= x+1）</code>，同时也发送一个自己的 <code>SYN</code> 包<code>（syn = y）</code>，即 <code>SYN+ACK </code>包，此时服务器进入 <code>SYN_RECV</code> 状态；</p></li><li><p>第三次握手：客户端收到服务器的 <code>SYN+ACK</code> 包，向服务器发送确认包 <code>ACK(ack= y+1</code>），此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（<code>TCP</code> 连接成功）状态，完成三次握手。</p></li></ul><h4 id="_4-次挥手" tabindex="-1"><strong>4 次挥手</strong> <a class="header-anchor" href="#_4-次挥手" aria-label="Permalink to &quot;**4 次挥手**&quot;">​</a></h4><ul><li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为 <code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 <code>FIN-WAIT-1（终止等待 1）状态</code>。 <code>TCP</code> 规定，<code>FIN</code> 报文段即使不携带数据，也要消耗一个序号。</p></li><li><p>服务器收到连接释放报文，发出确认报文，<code>ACK=1</code>，<code>ack=u+1</code>，并且带上自己的序列号 <code>seq=v</code>，此时，服务端就进入了 <code>CLOSE-WAIT</code>（关闭等待）状态。<code>TCP</code> 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 <code>CLOSE-WAIT</code> 状态持续的时间。</p></li><li><p>客户端收到服务器的确认请求后，此时，客户端就进入 <code>FIN-WAIT-2（终止等待 2）状态</code>，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p></li><li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1</code>，<code>ack=u+1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 <code>seq=w</code>，此时，服务器就进入了 <code>LAST-ACK（最后确认）</code>状态，等待客户端的确认。</p></li><li><p>客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK=1</code>，<code>ack=w+1</code>，而自己的序列号是 <code>seq=u+1</code>，此时，客户端就进入了 <code>TIME-WAIT时间等待）状态</code>。注意此时 <code>TCP</code> 连接还没有释放，必须经过 <code>2∗∗MSL（最长报文段寿命）</code>的时间后，当客户端撤销相应的 <code>TCB</code> 后，才进入 <code>CLOSED</code> 状态。</p></li><li><p>服务器只要收到了客户端发出的确认，立即进入 <code>CLOSED</code> 状态。同样，撤销 <code>TCB</code> 后，就结束了这次的 <code>TCP</code> 连接。</p></li><li><p>可以看到，服务器结束 <code>TCP</code> 连接的时间要比客户端早一些。</p></li></ul><h3 id="针对-3-次握手-4-次挥手常见面试题" tabindex="-1">针对 3 次握手，4 次挥手常见面试题 <a class="header-anchor" href="#针对-3-次握手-4-次挥手常见面试题" aria-label="Permalink to &quot;针对 3 次握手，4 次挥手常见面试题&quot;">​</a></h3><p>问题 🙋：</p><h4 id="为什么连接的时候是-3-次握手-关闭的时候却是-4-次挥手" tabindex="-1"><strong>为什么连接的时候是 3 次握手，关闭的时候却是 4 次挥手？</strong> <a class="header-anchor" href="#为什么连接的时候是-3-次握手-关闭的时候却是-4-次挥手" aria-label="Permalink to &quot;**为什么连接的时候是 3 次握手，关闭的时候却是 4 次挥手？**&quot;">​</a></h4><p>应为当服务端收到客户端的 <code>SYN</code> 连接请求报文后，可以直接发送 <code>SYN+ACK</code> 报文。其中 <code>ACK</code> 报文是用来应答的，<code>SYN</code> 报文是用来同步的。</p><p>但是关闭连接时，当服务端收到 <code>FIN</code> 报文时，很可能并不会立即关闭 <code>SOCKET</code>，所以只能先回复一个 <code>ACK</code> 报文，告诉客户端“你发的 <code>FIN</code> 报文我收到了”。</p><p>只有等到服务端所有的报文都发送完，客户短才能发送 <code>FIN</code> 报文，因此不能一起发送，所以需要 4 次挥手。</p><h4 id="为什么-time-wait-状态需要经过-2msl-最大报文短生存时间-才能返回到-close-状态" tabindex="-1"><strong>为什么 <code>TIME_WAIT</code> 状态需要经过 2MSL（最大报文短生存时间）才能返回到 <code>CLOSE</code> 状态？</strong> <a class="header-anchor" href="#为什么-time-wait-状态需要经过-2msl-最大报文短生存时间-才能返回到-close-状态" aria-label="Permalink to &quot;**为什么 `TIME_WAIT` 状态需要经过 2MSL（最大报文短生存时间）才能返回到 `CLOSE` 状态？**&quot;">​</a></h4><p>虽然按道理，四次报文都发送完毕，就可以直接进入 <code>CLOSE</code> 状态了，但是我们必须假象网络是不可靠的，有可能最后一个 <code>ACK</code> 丢失。所以 <code>TIME_WAIT</code> 状态就是用来重发可能丢失的 <code>ACK</code> 报文。</p><p>在客户端发送最后的 <code>ACK</code> 恢复，但 <code>ACK</code> 可能丢失。服务端如果没有收到 <code>ACK</code>，将不断重复发送 <code>FIN</code> 片段。所以客户端不能立即关闭，它必须确认服务端接收到了该 <code>ACK</code>。</p><p>客户端会在发送出 <code>ACK</code> 之后进入到 <code>TIME_WAIT</code> 状态。客户端会设置一个计时器，等待 <code>2MSL</code> 时间。如果在该时间内再次收到 FIN，那么客户端会重发 <code>ACK</code> 并在此等到 <code>2MSL</code>。</p><p><code>2MSL</code> 是 <code>2 倍的 MSL（Maximum Segment Lifetime）</code>。MSL 指一个片段在网络中的最大存活时间，<code>2MSL</code> 就是一个发送和一个回复所需的最大时间。如果直到 <code>2MSL</code>，客户端都没有再次收到 <code>FIN</code>，那么客户端推断 <code>ACK</code> 已经被成功接收，则结束 <code>TCP</code> 连接。</p><h4 id="为什么不能用两次握手进行连接" tabindex="-1"><strong>为什么不能用两次握手进行连接？</strong> <a class="header-anchor" href="#为什么不能用两次握手进行连接" aria-label="Permalink to &quot;**为什么不能用两次握手进行连接？**&quot;">​</a></h4><p>3 次握手完成两个重要功能，既要双方做好发送数据的准备工作，也要允许双方就序列号进行协商，这个序列号在握手过程中被发送和确认。 主机 <code>B </code>还不能确认主机 <code>A</code> 已经收到确认请求，也是说 <code>B</code> 认为建立好连接，开始发数据了，结果发出去的包一直 <code>A</code> 都没收到，那攻击 <code>B</code> 就很容易了，我专门发包不接收，服务器很容易就挂了。</p><h4 id="如果已经建立了连接-但是客户端突然出现故障了怎么办" tabindex="-1"><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong> <a class="header-anchor" href="#如果已经建立了连接-但是客户端突然出现故障了怎么办" aria-label="Permalink to &quot;**如果已经建立了连接，但是客户端突然出现故障了怎么办？**&quot;">​</a></h4><p><code>TCP</code> 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常设置为 2 小时，若 2 小时还没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍没反应，服务器就认为客户端出了故障，接着关闭连接。</p><h2 id="tcp-与-udp-的区别" tabindex="-1"><code>TCP</code> 与 <code>UDP</code> 的区别 <a class="header-anchor" href="#tcp-与-udp-的区别" aria-label="Permalink to &quot;`TCP` 与 `UDP` 的区别&quot;">​</a></h2><ul><li><code>TCP</code> 是面向链接的，而 <code>UDP</code> 是面向无连接的。</li><li><code>TCP</code> 仅支持单播传输，<code>UDP</code> 提供了单播，多播，广播的功能。</li><li><code>TCP</code> 的三次握手保证了连接的可靠性; <code>UDP</code> 是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接- 收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li><code>UDP</code> 的头部开销比 <code>TCP</code> 的更小，数据传输速率更高，实时性更好。</li></ul>',41)]))}const P=o(t,[["render",i]]);export{C as __pageData,P as default};
