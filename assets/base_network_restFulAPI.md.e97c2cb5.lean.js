import{_ as o,o as d,c,N as l}from"./chunks/framework.2f525601.js";const T=JSON.parse('{"title":"RestFul API","description":"","frontmatter":{},"headers":[],"relativePath":"base/network/restFulAPI.md","lastUpdated":1728985701000}'),t={name:"base/network/restFulAPI.md"};function a(r,e,i,s,u,h){return d(),c("div",null,e[0]||(e[0]=[l('<h1 id="restful-api" tabindex="-1">RestFul API <a class="header-anchor" href="#restful-api" aria-label="Permalink to &quot;RestFul API&quot;">​</a></h1><ul><li><code>RestFul</code> 是面向资源。</li><li><code>RestFul</code> 是一种架构的规范和约束、原则。</li><li><code>rest：</code>资源的表述性状态转移（表述性：客户端请求一个资源，服务器拿到这个资源）</li><li>资源的地址：在 <code>Web</code> 中就是 <code>URL</code>（统一资源标识符）</li><li>资源是 <code>Rest</code> 系统的核心概念，所有的设计都是以资源为中心。</li></ul><h2 id="restful-架构应该遵循统一接口原则" tabindex="-1"><code>RestFul</code> 架构应该遵循统一接口原则 <a class="header-anchor" href="#restful-架构应该遵循统一接口原则" aria-label="Permalink to &quot;`RestFul` 架构应该遵循统一接口原则&quot;">​</a></h2><p>不论什么样的资源，都是通过使用相同的接口进行资源的访问。</p><p><code>RestFul</code> 可以通过一套统一的接口为 <code>Web</code>，<code>iOS 和 Android</code>提供服务。</p><p><code>RestFul</code> 架构风格规定，数据的元操作，即 <code>CRUD(create, read, update 和 delete,即数据的增删查改)</code>操作，分别对应于 <code>HTTP</code> 方法：</p><ul><li><code>GET</code> 用来获取资源</li><li><code>POST</code> 用来新建资源（也可以用于更新资源）</li><li><code>PUT</code> 用来更新资源，<code>DELETE</code> 用来删除资源，这样就统一了数据操作的接口，仅通过 <code>HTTP</code> 方法，就可以完成对数据的所有增删查改工作。</li></ul><h2 id="rest-和-restful-的区别" tabindex="-1"><code>rest</code> 和 <code>RestFul</code> 的区别 <a class="header-anchor" href="#rest-和-restful-的区别" aria-label="Permalink to &quot;`rest` 和 `RestFul` 的区别&quot;">​</a></h2><ul><li><code>rest</code> 是一种架构风格。</li><li><code>RestFul</code> 是遵循了 <code>rest</code> 的原则 的<code>web</code>服务。</li><li><code>retFul</code> 是有 <code>rest</code> 衍生出来的。</li></ul><h3 id="rest-原则" tabindex="-1"><code>rest</code> 原则 <a class="header-anchor" href="#rest-原则" aria-label="Permalink to &quot;`rest` 原则&quot;">​</a></h3><ol><li>网络上的所有事物都被抽象为资源。</li><li>每一个资源都有一个唯一的资源标识符。</li><li>同一个资源具有多种表现形式<code>（xml、json 等）</code>。</li><li>对于资源的各种操作不会改变资源的标识符。</li><li>所有操作都是无状态的。</li></ol><h3 id="什么是无状态和有状态" tabindex="-1">什么是无状态和有状态 <a class="header-anchor" href="#什么是无状态和有状态" aria-label="Permalink to &quot;什么是无状态和有状态&quot;">​</a></h3><ul><li>有状态：后面每一个状态都依赖于前面的状态，没有一个 <code>url</code>，能够直接定位到想要的资源。</li><li>无状态：对每个资源请求，都不依赖于其他资源或其他请求。每个资源都可以寻址的，都有至少一个 <code>url</code> 能对其定位的。</li></ul><h3 id="在-restful-之前的操作" tabindex="-1">在 <code>RestFul</code> 之前的操作 <a class="header-anchor" href="#在-restful-之前的操作" aria-label="Permalink to &quot;在 `RestFul` 之前的操作&quot;">​</a></h3><ul><li><a href="http://127.0.0.1/user/query/1" target="_blank" rel="noreferrer">http://127.0.0.1/user/query/1</a> <code>GET</code>   根据用户 <code>id</code> 查询用户数据</li><li><a href="http://127.0.0.1/user/save" target="_blank" rel="noreferrer">http://127.0.0.1/user/save</a> <code>POST</code> 新增用户</li><li><a href="http://127.0.0.1/user/update" target="_blank" rel="noreferrer">http://127.0.0.1/user/update</a> <code>POST</code> 修改用户信息</li><li><a href="http://127.0.0.1/user/delete" target="_blank" rel="noreferrer">http://127.0.0.1/user/delete</a> <code>GET/POST</code> 删除用户信息</li></ul><h3 id="restful-用法" tabindex="-1"><code>RestFul</code> 用法 <a class="header-anchor" href="#restful-用法" aria-label="Permalink to &quot;`RestFul` 用法&quot;">​</a></h3><ul><li><a href="http://127.0.0.1/user/1" target="_blank" rel="noreferrer">http://127.0.0.1/user/1</a> <code>GET</code>   根据用户 <code>id</code> 查询用户数据</li><li><a href="http://127.0.0.1/user" target="_blank" rel="noreferrer">http://127.0.0.1/user</a>  <code>POST</code>  新增用户</li><li><a href="http://127.0.0.1/user" target="_blank" rel="noreferrer">http://127.0.0.1/user</a>  <code>PUT</code>  修改用户信息</li><li><a href="http://127.0.0.1/user" target="_blank" rel="noreferrer">http://127.0.0.1/user</a>  <code>DELETE</code>  删除用户信息</li></ul><h2 id="restful-中的请求方法有哪些" tabindex="-1"><code>RestFul</code> 中的请求方法有哪些 <a class="header-anchor" href="#restful-中的请求方法有哪些" aria-label="Permalink to &quot;`RestFul` 中的请求方法有哪些&quot;">​</a></h2><p><code>get</code>、<code>post</code>、<code>put</code>、<code>delete</code>、<code>head</code>、<code>options</code>。</p><h3 id="put" tabindex="-1"><code>PUT</code> <a class="header-anchor" href="#put" aria-label="Permalink to &quot;`PUT`&quot;">​</a></h3><p><code>PUT</code> 方法在 <code>REST</code> 中主要用于更新资源。</p><p><code>PUT</code> 请求通常带有资源的全部信息，表示该资源在服务器上的整体替换操作。</p><p><code>PUT</code> 方法是幂等的：这意味着对于同一个资源，如果多次发出内容相同的 <code>PUT</code> 请求，其结果都是一致的。例如，如果你发送 <code>/user</code> 请求更新用户的 <code>name</code> 为 <code>steinsGate</code>，无论请求发出多少次，最终的 <code>name</code> 都是 <code>steinsGate</code>，不会产生其他副作用。</p><p><code>PUT</code> 请求的数据通常放在请求的消息体中，类似于 <code>POST</code> 请求。与 <code>POST</code> 不同，<code>PUT</code> 是幂等的，因为它对同一资源重复执行多次操作，不会导致新的变化（只要数据一致）。</p><h3 id="delete" tabindex="-1"><code>DELETE</code> <a class="header-anchor" href="#delete" aria-label="Permalink to &quot;`DELETE`&quot;">​</a></h3><p><code>DELETE</code> 方法在 <code>REST</code> 请求中主要用于删除资源。</p><p><code>DELETE</code> 方法也是幂等的：无论删除同一个资源多少次，最终的结果都是该资源被删除。再次对已删除的资源发出 <code>DELETE</code> 请求，不会对服务器状态产生任何新的变化。</p><h3 id="options" tabindex="-1"><code>OPTIONS</code> <a class="header-anchor" href="#options" aria-label="Permalink to &quot;`OPTIONS`&quot;">​</a></h3><p><code>options</code> 请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发<code>put</code>，<code>delete</code> 请求。</p><p>至于什么情况下浏览器会发预检请求，浏览器会会将请求分为两类，简单请求与非简单请求，非简单请求会产生预检 <code>options</code> 请求。</p><h3 id="get-与-post" tabindex="-1"><code>GET</code> 与 <code>POST</code> <a class="header-anchor" href="#get-与-post" aria-label="Permalink to &quot;`GET` 与 `POST`&quot;">​</a></h3><hr><h4 id="常见说法" tabindex="-1">常见说法 <a class="header-anchor" href="#常见说法" aria-label="Permalink to &quot;常见说法&quot;">​</a></h4><ul><li><code>GET</code> 使用 <code>URL</code> 或 <code>Cookie</code> 传参，而 <code>POST</code> 将数据放在消息体（<code>BODY</code>）中。</li><li><code>GET</code> 方式提交的数据有长度限制，而 <code>POST</code> 的数据可以非常大。</li><li><code>POST</code> 比 <code>GET</code> 更安全，因为数据不会在地址栏中显示。</li></ul><p>虽然这些说法在某些场景下有一定的参考意义，但它们并不完全正确或全面。我们需要更深入地理解 <code>GET</code> 和 <code>POST</code> 的本质区别。</p><h4 id="get-与-post-的实际区别" tabindex="-1"><code>GET</code> 与 <code>POST</code> 的实际区别 <a class="header-anchor" href="#get-与-post-的实际区别" aria-label="Permalink to &quot;`GET` 与 `POST` 的实际区别&quot;">​</a></h4><p><strong>1. 数据传递方式：</strong></p><ul><li><code>GET</code> 请求一般用于从服务器获取资源。通常，参数会被包含在 <code>URL</code> 中，附加在请求的路径后（通过查询字符串的形式）。虽然 <code>HTTP</code> 协议允许 <code>GET</code> 请求有消息体，但大多数服务器和浏览器对消息体的支持有限或直接忽略，因此实际应用中 <code>GET</code> 请求的参数基本放在 <code>URL</code> 中。</li><li><code>POST</code> 请求用于向服务器发送数据，通常用于创建或更新资源。参数通常放在消息体（<code>BODY</code>）中，而不是 <code>URL</code> 中。这使得 <code>POST</code> 请求适合于发送较大的数据。</li></ul><p><strong>2. 数据量限制：</strong></p><ul><li><code>HTTP</code> 协议本身并没有对 <code>GET</code> 或 <code>POST</code> 的数据长度作出限制。<code>GET</code> 请求的长度限制主要来自于浏览器和服务器的实现，一些浏览器和服务器对 <code>URL</code> 长度有上限（例如，<code>IE</code> 对 <code>URL</code> 长度的限制为 <code>2083</code> 字节）。这通常是为了避免某些安全性和性能问题，如防止通过构造超长的 <code>URL</code> 来对服务器进行攻击。</li><li><code>POST</code> 请求则可以在消息体中携带大量数据，理论上没有限制，但实际中的大小限制则由服务器设置来控制。</li></ul><p><strong>3. 安全性：</strong></p><ul><li><code>GET</code> 请求的参数会被直接暴露在 <code>URL</code> 中，因此在浏览器历史记录、服务器日志或缓存中都有可能泄露。对于敏感数据，直接使用 <code>GET</code> 是不安全的。</li><li><code>POST</code> 请求的数据在消息体中传递，在地址栏中不可见，这减少了某些泄露风险。但这并不意味着 <code>POST</code> 天然比 <code>GET</code> 更安全。数据的安全性主要取决于传输协议。例如，在使用 <code>HTTPS</code> 时，无论是 <code>GET</code> 还是 <code>POST</code>，传输的数据都会被加密，因而两者在传输层面都是安全的。而在 <code>HTTP</code> 下，两者的传输内容都是明文，安全性较低。</li></ul><p><strong>4. 幂等性：</strong></p><ul><li><code>GET</code> 请求应当是幂等的：对同一资源多次执行相同的 <code>GET</code> 请求，不应该改变资源的状态。例如，多次访问同一个页面并不会改变它的内容。</li><li><code>POST</code> 请求通常不是幂等的：因为 <code>POST</code> 请求用于创建或更新资源，每次 <code>POST</code> 操作都可能改变服务器的状态。比如，向某个 <code>API POST</code> 数据可能会创建多个相同的资源，这与 <code>GET</code> 请求有本质上的区别。</li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><ul><li><strong>GET</strong> 用于从服务器获取数据，并且应当是幂等的。这意味着多次请求不会导致资源状态的变化。</li><li><strong>POST</strong> 用于向服务器发送数据，通常用于创建或修改资源。<code>POST</code> 请求不是幂等的，多次发送 <code>POST</code> 请求会对资源状态产生不同的影响。</li></ul><p>因此，在设计 <code>API</code> 时，应当根据操作的性质选择合适的请求方法：如果是获取数据，使用 <code>GET</code>；如果是提交数据并创建资源，使用 <code>POST</code>。确保对幂等操作（如更新数据）使用正确的 <code>HTTP</code> 方法，例如 <code>PUT</code> 或 <code>DELETE</code>，而不是 <code>POST</code>。</p>',47)]))}const p=o(t,[["render",a]]);export{T as __pageData,p as default};
