import{_ as a,o as e,c as l,Q as i}from"./chunks/framework.a5035e6c.js";const b=JSON.parse('{"title":"执行上下文","description":"","frontmatter":{},"headers":[],"relativePath":"base/javaScript/context.md","lastUpdated":1697768968000}'),t={name:"base/javaScript/context.md"},r=i('<h1 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h1><h2 id="什么是执行上下文" tabindex="-1">什么是执行上下文？ <a class="header-anchor" href="#什么是执行上下文" aria-label="Permalink to &quot;什么是执行上下文？&quot;">​</a></h2><p>执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h2 id="执行上下文的理解" tabindex="-1">执行上下文的理解： <a class="header-anchor" href="#执行上下文的理解" aria-label="Permalink to &quot;执行上下文的理解：&quot;">​</a></h2><p>执行上下文可以简单理解为一个对象:</p><ul><li>它包含三个部分: <ul><li>变量对象(VO)</li><li>作用域链(词法作用域)</li><li>this 指向</li></ul></li><li>它的类型: <ul><li>全局执行上下文：这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置  this  的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li>函数执行上下文：每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。</li><li>eval 执行上下文</li></ul></li><li>代码执行过程: <ul><li>创建 全局上下文 (global EC)</li><li>全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被 push 到执行栈顶层</li><li>函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起</li><li>函数执行完后，callee 被 pop 移除出执行栈，控制权交还全局上下文 (caller)，继续执行</li></ul></li></ul><h3 id="变量对象" tabindex="-1">变量对象 <a class="header-anchor" href="#变量对象" aria-label="Permalink to &quot;变量对象&quot;">​</a></h3><p>变量对象，是执行上下文中的一部分，可以抽象为一种   数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有   变量和函数声明(不包含函数表达式)。</p><h3 id="活动对象-ao" tabindex="-1">活动对象 (AO) <a class="header-anchor" href="#活动对象-ao" aria-label="Permalink to &quot;活动对象 (AO)&quot;">​</a></h3><p>当变量对象所处的上下文为 active EC 时，称为活动对象。</p><h2 id="执行栈" tabindex="-1">执行栈 <a class="header-anchor" href="#执行栈" aria-label="Permalink to &quot;执行栈&quot;">​</a></h2>',11),o=[r];function c(n,s,h,d,p,_){return e(),l("div",null,o)}const m=a(t,[["render",c]]);export{b as __pageData,m as default};
