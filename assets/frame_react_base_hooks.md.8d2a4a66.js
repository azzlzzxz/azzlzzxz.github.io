import{_ as a,o as t,c as o,N as c}from"./chunks/framework.5873b8fd.js";const p=JSON.parse('{"title":"Hooks 相关知识","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/base/hooks.md","lastUpdated":1727446215000}'),d={name:"frame/react/base/hooks.md"};function r(s,e,l,i,n,h){return t(),o("div",null,e[0]||(e[0]=[c('<h1 id="hooks-相关知识" tabindex="-1">Hooks 相关知识 <a class="header-anchor" href="#hooks-相关知识" aria-label="Permalink to &quot;Hooks 相关知识&quot;">​</a></h1><h2 id="setstate-是同步还是异步" tabindex="-1">setState 是同步还是异步 <a class="header-anchor" href="#setstate-是同步还是异步" aria-label="Permalink to &quot;setState 是同步还是异步&quot;">​</a></h2><p><code>setState</code> 在类组件中是 <code>this.setState</code> 方法，在函数组件中是 <code>useState</code> 返回值的修改函数 <code>setState</code> 用于变更状态，触发组件重新渲染，更新视图 <code>UI</code></p><ul><li>关于<code>useState</code>的实现可以看这里 <a href="/rsource/react/useState"><u>React 18.2 | useState 实现 🚀</u></a></li></ul><h3 id="在-react-18-之前" tabindex="-1">在 <code>React 18</code> 之前 <a class="header-anchor" href="#在-react-18-之前" aria-label="Permalink to &quot;在 `React 18` 之前&quot;">​</a></h3><p>在 <code>React 18</code> 之前，只要在 <code>React</code> 可以控制的地方，<code>setState</code> 的执行都是异步的，比如在 <code>React</code> 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略</p><p>而在 <code>React</code> 无法控制的地方，如监听原生事件和异步调用的地方，<code>setState</code> 的执行都是就是同步的。比如在 <code>addEventListener</code>、<code>setTimeout</code>、<code>Promise</code> 等的回调函数中</p><h3 id="在-react-18-之后" tabindex="-1">在 <code>React 18</code> 之后 <a class="header-anchor" href="#在-react-18-之后" aria-label="Permalink to &quot;在 `React 18` 之后&quot;">​</a></h3><p>在 <code>concurrent</code> 模式下，由于默认启用了并发更新，所以 <code>setState</code> 的执行都是异步的，即不管是在 <code>React</code> 可以控制的地方还是无法控制的地方，默认都会走合并操作，延迟更新的策略</p><div class="tip custom-block"><p class="custom-block-title"><code>setState</code> 为什么是异步的？</p><ul><li>性能优化、减少渲染次数</li></ul><p>从源码的角度分析，在执行任务调度之前，回去判断当前正在更新的 lane 优先级和老的更新优先级做对比，如果优先级一样就开启了批处理，就不需要再次调度新任务执行更新了。（源码地址 <a href="https://github.com/azzlzzxz/react-v18.2.0/blob/75de845d69876d84a4a8b226c5f2e6203328b8ee/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L715" target="_blank" rel="noreferrer"><u>批处理</u></a>）</p><ul><li>保持内部一致性</li></ul></div><h2 id="闭包陷阱" tabindex="-1">闭包陷阱 <a class="header-anchor" href="#闭包陷阱" aria-label="Permalink to &quot;闭包陷阱&quot;">​</a></h2>',11)]))}const b=a(d,[["render",r]]);export{p as __pageData,b as default};
