# Rspack

`Rspack` 是一个基于 `Rust` 编写的高性能`Javascript`打包工具，它提供对`webpack`生态，良好的兼容性，能够无缝切换`webpack`，提供快速构建

**你只要会`Webpack`，切`Rspack`就无压力**

并且相比于`webpack`，`rspack`在冷启动和`build`构建时间都远远的快于`webpack`

| 3 次构建              | rsapck | webapck                     |
| --------------------- | ------ | --------------------------- |
| build（3 次平均时间） | 2.8s   | 35s                         |
| dev（3 次平均时间）   | 3.4s   | 40s（有缓存的情况 3s 左右） |
| size                  | 1.75m  | 1.45m                       |

::: info 相关资料

- [<u>Rspack 官网</u>](https://rspack.dev/zh/)

:::

## 迁移 `webpack`

### 修改 `package.json`

```json{5,6}
{
  "scripts": {
-   "serve": "webpack serve",
-   "build": "webpack build",
+   "serve": "rspack serve",
+   "build": "rspack build",
  }
}
```

### 修改配置

将 `webpack.config.js` 文件重命名为 `rspack.config.js`

::: info 相关资料

- [<u>迁移 webpack</u>](https://rspack.dev/zh/guide/migration/webpack#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE)

:::

## 迁移 `CRA` 或 `CRACO`

::: info 相关资料

- [<u>迁移 CRA</u>](https://rsbuild.dev/zh/guide/migration/cra)

:::

## `Rspack`为什么快

`Rspack` 的核心是使用 `Rust` 语言编写的，`Rust` 可以更好地管理内存、并行执行任务和避免垃圾回收带来的性能损耗。这使得 `Rspack` 在处理大量文件和复杂构建任务时，能够更快地完成编译和打包。

::: tip 社区讨论

- [<u>vite 大型项目页面重载速度过慢，切换 Rspack</u>](https://github.com/vitejs/vite/discussions/13697#discussioncomment-10241433)

:::

### 多线程并行编译

利用 `Rust` 的并发能力，支持多线程并行编译。相比之下，`Webpack` 由于使用 `JavaScript` 引擎（单线程运行的 `V8`），虽然也可以通过一些插件（如 `Thread-loader`）实现并行任务，但效率和 `Rust` 原生多线程相比仍有较大差距。

::: tip 并行执行任务

- `Rspack` 通过多线程能够同时执行多个构建任务，如解析模块、执行 `Tree Shaking`、压缩代码等，极大地提升了编译和打包的速度，尤其是在多核 `CPU` 机器上表现尤为明显。

:::

### 增量构建和缓存优化

::: tip 文件系统缓存

- `Rspack` 使用了高效的文件系统缓存机制，这意味着在多次构建相同项目时，它能够跳过已经编译好的模块，极大地提升了二次构建的速度。

- `Webpack` 的缓存机制虽然经过多次改进，但由于使用 `JavaScript` 实现，性能不如 `Rust` 实现的缓存系统。

:::

::: tip 增量构建

- `Rspack` 的增量构建机制更加，当项目中的某些文件发生变化时，它只会重新构建受影响的部分。

- `Webpack` 在重新编译时，会有大量不必要的模块。

这使得 `Rspack` 在日常开发的构建速度（如热更新和局部编译）上速度更快。

:::

### 更快的冷启动

- 模块缓存优化：即使是初次启动，`Rspack` 也能够通过模块缓存机制减少模块解析时间。

- 多线程预加载：在冷启动过程中，`Rspack` 能够同时并行处理多个模块的加载和解析任务，这大大加快了启动速度。

- `Rust` 的高效执行：`Rust` 语言的高效性能和 `Webpack` 使用 `JavaScript` 语言本身的运行时性能差异，使得 `Rspack` 能够在执行过程中更快地完成启动。

::: tip Rspack 的缓存机制相较 Webpack 的优势

- 缓存命中率更高

由于 `Rspack` 采用的是 模块级别缓存 和 模块哈希比对，使得缓存命中率相比 `Webpack` 更高。即使是 `Webpack 5` 引入了持久缓存机制，但 `Rspack` 的模块缓存更快。

- 初次启动也能加速

通常缓存机制在首次构建时不会起作用，而 `Rspack` 的设计使得即使是第一次启动，也能通过模块缓存加速后续的构建过程。这是由于 `Rspack` 的缓存系统并不需要前置的构建，而是动态地在首次构建中就开始缓存

- 更快的冷启动

`Rspack` 能够大幅减少模块解析和依赖图的构建时间，这使得冷启动速度明显提升。
:::

::: tip Rspack 模块缓存的运作流程

- 解析模块：当 `Rspack` 解析一个模块时，会计算其内容的哈希值，并生成模块的依赖图。这个过程会被缓存起来，以便在下一次构建时可以复用。

- 生成缓存：在模块被成功解析和打包后，`Rspack` 会将这些模块的内容（包括模块代码和依赖关系）存储到内存或磁盘中，作为后续构建的缓存。

- 哈希比对：在后续构建时，`Rspack` 会为每个模块重新计算哈希值，与缓存中的哈希值进行比对。如果哈希值相同，表示模块内容未变，直接使用缓存；如果哈希值不同，才重新解析该模块。

- 模块替换和依赖更新：在增量构建过程中，`Rspack` 只会替换那些发生变化的模块，同时更新相应的依赖图，未变动的部分不会重新打包或解析。

:::

### 更快的打包构建

- 并发处理

`Rspack` 是用 `Rust` 编写的，提供并发处理能力，充分利用多核 `CPU` 的能力。在构建过程中的许多任务可以并行执行，例如模块解析、代码优化等，`Rspack` 能够大幅提升并行任务的处理效率。

- 基于高效缓存的增量编译

- 并行化和异步化的 `I/O` 处理，减少了文件系统操作的时间。
