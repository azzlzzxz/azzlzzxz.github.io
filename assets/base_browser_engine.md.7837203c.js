import{_ as e,o as c,c as a,N as d}from"./chunks/framework.2673bc46.js";const g=JSON.parse('{"title":"浏览器 V8 引擎","description":"","frontmatter":{},"headers":[],"relativePath":"base/browser/engine.md","lastUpdated":1727667273000}'),t={name:"base/browser/engine.md"};function s(r,o,l,n,p,i){return c(),a("div",null,o[0]||(o[0]=[d('<h1 id="浏览器-v8-引擎" tabindex="-1">浏览器 V8 引擎 <a class="header-anchor" href="#浏览器-v8-引擎" aria-label="Permalink to &quot;浏览器 V8 引擎&quot;">​</a></h1><h2 id="v8-如何执行一段-js-代码" tabindex="-1">V8 如何执行一段 JS 代码 <a class="header-anchor" href="#v8-如何执行一段-js-代码" aria-label="Permalink to &quot;V8 如何执行一段 JS 代码&quot;">​</a></h2><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/v8.png" alt=""></p><ol><li>预解析：检查语法错误但不生成<code>AST</code>。</li><li>生成<code>AST</code>：经过词法/语法分析，生成抽象语法树。</li><li>生成字节码：基线编译器<code>(Ignition)</code>将<code>AST</code>转换成字节码。</li><li>生成机器码：优化编译器<code>(Turbofan)</code>将字节码转换成优化过的机器码，此外在逐行执行字节码的过程中，如果一段代码经常被执行，那么 <code>V8</code>会将这段代码直接转换成机器码保存起来，下一次执行就不必经过字节码，优化了执行速度。</li></ol><h2 id="介绍一下引用计数和标记清除" tabindex="-1">介绍一下引用计数和标记清除 <a class="header-anchor" href="#介绍一下引用计数和标记清除" aria-label="Permalink to &quot;介绍一下引用计数和标记清除&quot;">​</a></h2><h3 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h3><p>给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。</p><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h3><p>垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。</p><h2 id="v8-如何进行垃圾回收" tabindex="-1"><code>V8</code> 如何进行垃圾回收 <a class="header-anchor" href="#v8-如何进行垃圾回收" aria-label="Permalink to &quot;`V8` 如何进行垃圾回收&quot;">​</a></h2><h3 id="为什么要有垃圾回收" tabindex="-1">为什么要有垃圾回收? <a class="header-anchor" href="#为什么要有垃圾回收" aria-label="Permalink to &quot;为什么要有垃圾回收?&quot;">​</a></h3><p>在<code>C 语言</code>和<code>C++语言</code>中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过<code>malloc</code>函数去手动分配，在用完之后，还要时刻记得用 free 函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。</p><p>但是我们在写<code>JavaScript</code>的时候，却没有这个过程，因为人家已经替我们封装好了，<code>V8</code>引擎会根据你当前定义对象的大小去自动申请分配内存。</p><p>不需要我们去手动管理内存了，所以自然要有垃圾回收，否则的话只分配不回收，岂不是没多长时间内存就被占满了吗，导致应用崩溃。</p><p>垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。</p><p><code>JS</code>引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/stack.png" alt="stack"></p><ul><li><p>栈内存的回收： 栈内存调用栈上下文切换后就被回收，比较简单</p></li><li><p>堆内存的回收： <code>V8</code>的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长</p></li></ul><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/mechanism.png" alt="mechanism"></p><h3 id="新生代内存回收机制" tabindex="-1">新生代内存回收机制： <a class="header-anchor" href="#新生代内存回收机制" aria-label="Permalink to &quot;新生代内存回收机制：&quot;">​</a></h3><p>新生代内存容量小，<code>64 位系统</code>下仅有<code> 32M</code>。新生代内存分为<code>From、To</code>两部分，进行垃圾回收时，先扫描<code> From</code>，将非存活对象回收，将存活对象顺序复制到<code>To</code>中，之后调换<code> From/To</code>，等待下一次回收。</p><ol><li>分配方式</li></ol><p>新生代存的都是生存周期短的对象，分配内存也很容易，只保存一个指向内存空间的指针，根据分配对象的大小递增指针就可以了，当存储空间快要满时，就进行一次垃圾回收。</p><ol start="2"><li>算法</li></ol><p>新生代采用<code>Scavenge</code>垃圾回收算法，在算法实现时主要采用<code>Cheney</code>算法。</p><p><code>Cheney</code>算法将内存一分为二，叫做<code>semispace</code>，一块处于使用状态，一块处于闲置状态。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/cheney.png" alt="Cheney"></p><p>处于使用状态的<code>semispace</code>称为<code>From</code>空间，处于闲置状态的<code>semispace</code>称为<code>To</code>空间。</p><p>我画了一套详细的流程图，接下来我会结合流程图来详细说明<code>Cheney</code>算法是怎么工作的。 垃圾回收在下面我统称为<code>GC（Garbage Collection）</code>。</p><ol><li><strong>在<code>From</code>空间中分配了 3 个对象 A、B、C</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from.png" alt="from"></p><ol start="2"><li><strong><code>GC</code> 进来判断对象 B 没有其他引用，可以回收，对象 A 和 C 依然为活跃对象</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_B.png" alt="from_B"></p><ol start="3"><li><strong>将活跃对象 A、C 从 From 空间复制到<code>To</code>空间</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_toAC.png" alt="from_toAC"></p><ol start="4"><li><strong>清空<code>From</code>空间的全部内存</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_clear.png" alt="from_clear"></p><ol start="5"><li><strong>交换<code>From</code>空间和<code>To</code>空间</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/interchange_from_to.png" alt="interchange_from_to"></p><ol start="6"><li><strong>在<code>From</code>空间中又新增了 2 个对象 D、E</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_add.png" alt="from_add"></p><ol start="7"><li><strong>下一轮<code>GC</code>进来发现对象 D 没有引用了，做标记</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_next.png" alt="from_next"></p><ol start="8"><li><strong>将活跃对象 A、C、E 从 From 空间复制到<code>To</code>空间</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_CE.png" alt="from_CE"></p><ol start="9"><li><strong>清空<code>From</code>空间全部内存</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_clear_again.png" alt="from_clear_again"></p><ol start="10"><li><strong>继续交换<code>From</code>空间和<code>To</code>空间，开始下一轮</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/from_to_next.png" alt="from_to_next"></p><p>通过上面的流程图，我们可以很清楚的看到，进行<code>From</code>和<code>To</code>交换，就是为了让活跃对象始终保持在一块<code>semispace</code>中，另一块 <code>semispace</code> 始终保持空闲的状态。</p><p><code>Scavenge</code> 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。<code>Scavenge</code> 的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。</p><p>由于<code>Scavenge</code>是典型的牺牲空间换取时间的算法，所以无法大规模的应用到所有的垃圾回收中。但我们可以看到，<code>Scavenge</code> 非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p><h2 id="晋升" tabindex="-1">晋升 <a class="header-anchor" href="#晋升" aria-label="Permalink to &quot;晋升&quot;">​</a></h2><p>当一个对象经过多次复制仍然存活时，它就会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。</p><p>对象从新生代移动到老生代的过程叫作晋升。</p><p>对象晋升的条件主要有两个：</p><ol><li>对象从<code>From</code>空间复制到<code>To</code>空间时，会检查它的内存地址来判断这个对象是否已经经历过一次<code>Scavenge</code>回收。如果已经经历过了，会将该对象从<code>From</code>空间移动到老生代空间中，如果没有，则复制到<code>To</code>空间。总结来说，如果一个对象是第二次经历从<code>From</code>空间复制到 To 空间，那么这个对象会被移动到老生代中。</li><li>当要从<code>From</code>空间复制一个对象到<code>To</code>空间时，如果<code>To</code> 空间已经使用了超过 25%，则这个对象直接晋升到老生代中。设置 25%这个阈值的原因是当这次<code>Scavenge</code>回收完成后，这个<code>To</code>空间会变为<code>From</code>空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。</li></ol><h2 id="老生代内存回收机制" tabindex="-1">老生代内存回收机制 <a class="header-anchor" href="#老生代内存回收机制" aria-label="Permalink to &quot;老生代内存回收机制&quot;">​</a></h2><ul><li>晋升：如果新生代的变量经过多次回收依然存在，那么就会被放入老生代内存中。</li><li>标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或被强引用的对象取消标记，回收被标记的对象。</li><li>整理内存碎片：把对象挪到内存的一端。</li></ul><h3 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h3><p>在老生代中，存活对象占较大比重，如果继续采用<code>Scavenge</code>算法进行管理，就会存在两个问题：</p><ol><li>由于存活对象较多，复制存活对象的效率会很低。</li><li>2.采用 Scavenge 算法会浪费一半内存，由于老生代所占堆内存远大于新生代，所以浪费会很严重。</li></ol><p>所以，<code>V8</code> 在老生代中主要采用了<code>Mark-Sweep</code>和<code>Mark-Compact</code>相结合的方式进行垃圾回收。</p><h3 id="mark-sweep" tabindex="-1"><code>Mark-Sweep</code> <a class="header-anchor" href="#mark-sweep" aria-label="Permalink to &quot;`Mark-Sweep`&quot;">​</a></h3><p><code>Mark-Sweep</code> 是标记清除的意思，它分为标记和清除两个阶段。</p><p>与<code>Scavenge</code>不同，<code>Mark-Sweep</code> 并不会将内存分为两份，所以不存在浪费一半空间的行为。<code>Mark-Sweep</code> 在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。</p><p>也就是说，<code>Scavenge</code> 只复制活着的对象，而<code>Mark-Sweep</code>只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。</p><p>我们还是通过流程图来看一下：</p><ol><li><strong>老生代中有对象 A、B、C、D、E、F</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/old_obj.png" alt="old_obj"></p><ol start="2"><li><strong><code>GC</code> 进入标记阶段，将 A、C、E 标记为存活对象</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/old_mark.png" alt="old_mark"></p><ol start="3"><li><strong><code>GC</code> 进入清除阶段，回收掉死亡的 B、D、F 对象所占用的内存空间</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/old_clear.png" alt="old_clear"></p><p><strong>可以看到，<code>Mark-Sweep</code> 最大的问题就是，在进行一次清除回收以后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题。</strong></p><p>如果出现需要分配一个大内存的情况，由于剩余的碎片空间不足以完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的</p><h3 id="mark-compact" tabindex="-1"><code>Mark-Compact</code> <a class="header-anchor" href="#mark-compact" aria-label="Permalink to &quot;`Mark-Compact`&quot;">​</a></h3><p>为了解决<code>Mark-Sweep</code>的内存碎片问题，<code>Mark-Compact</code> 就被提出来了。</p><p>**<code>Mark-Compact</code> 是标记整理的意思，**是在<code>Mark-Sweep</code>的基础上演变而来的。<code>Mark-Compact</code> 在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。如下图所示：</p><ol><li><strong>老生代中有对象 A、B、C、D、E、F（和<code>Mark—Sweep</code>一样）</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/old_obj.png" alt="old_obj"></p><ol start="2"><li><strong><code>GC</code>进入标记阶段，将 A、C、E 标记为存活对象（和<code>Mark—Sweep</code>一样）</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/compact_old_mark.png" alt="compact_old_mark"></p><ol start="3"><li><strong><code>GC</code> 进入整理阶段，将所有存活对象向内存空间的一侧移动，灰色部分为移动后空出来的空间</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/compact_tidy.png" alt="compact_tidy"></p><ol start="4"><li><strong><code>GC</code> 进入清除阶段，将边界另一侧的内存一次性全部回收</strong></li></ol><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/compact_old_clear.png" alt="compact_old_clear"></p><h2 id="两者结合" tabindex="-1">两者结合 <a class="header-anchor" href="#两者结合" aria-label="Permalink to &quot;两者结合&quot;">​</a></h2><p>在<code>V8</code>的回收策略中，<code>Mark-Sweep</code> 和<code>Mark-Conpact</code>两者是结合使用的。</p><p>由于<code>Mark-Conpact</code>需要移动对象，所以它的执行速度不可能很快，在取舍上，<code>V8</code> 主要使用<code>Mark-Sweep</code>，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用<code>Mark-Compact</code>。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>V8</code>的垃圾回收机制分为新生代和老生代。</p><p>新生代主要使用<code>Scavenge</code>进行管理，主要实现是<code>Cheney</code>算法，将内存平均分为两块，使用空间叫<code>From</code>，闲置空间叫<code>To</code>，新对象都先分配到 From 空间中，在空间快要占满时将存活对象复制到<code>To</code>空间中，然后清空<code>From</code>的内存空间，此时，调换<code>From</code>空间和<code>To</code>空间，继续进行内存分配，当满足那两个条件时对象会从新生代晋升到老生代。</p><p>老生代主要采用<code>Mark-Sweep</code>和 <code>Mark-Compact</code> 算法，一个是标记清除，一个是标记整理。两者不同的地方是，<code>Mark-Sweep</code> 在垃圾回收后会产生碎片内存，而<code>Mark-Compact</code>在清除前会进行一步整理，将存活对象向一侧移动，随后清空边界的另一侧内存，这样空闲的内存都是连续的，但是带来的问题就是速度会慢一些。在<code>V8</code>中，老生代是<code>Mark-Sweep</code>和<code>Mark-Compact</code>两者共同进行管理的。</p><h2 id="内存结构分配" tabindex="-1">内存结构分配 <a class="header-anchor" href="#内存结构分配" aria-label="Permalink to &quot;内存结构分配&quot;">​</a></h2><p>由于<code>V8</code>最开始就是为<code>JavaScript</code>在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，在 64 位系统下大约为 1.4GB，在 32 位系统下大约为 700MB。</p><p>在 NodeJS 环境中，我们可以通过 <strong>process.memoryUsage()</strong> 来查看内存分配</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/process.png" alt="process"></p><p><code>process.memoryUsage</code>返回一个对象，包含了<code>Node</code>进程的内存占用信息。该对象包含四个字段，含义如下:</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/process_memoryUsage.png" alt="process_memoryUsage"></p><ul><li><code>rss（resident set size）</code>：所有内存占用，包括指令区和堆栈</li><li><code>heapTotal</code>：V8 引擎可以分配的最大堆内存，包含下面的 <code>heapUsed</code></li><li><code>heapUsed</code>：V8 引擎已经分配使用的堆内存</li><li><code>external</code>：V8 管理<code>C++</code>对象绑定到<code>JavaScript</code>对象上的内存</li></ul><p>以上所有内存单位均为字节<code>（Byte）</code></p><p>如果说想要扩大<code>Node</code>可用的内存空间，可以使用<code>Buffer</code>等堆外内存内存:</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/node.png" alt="node"></p><p><code>Node Standard Library:</code> 是我们每天都在用的标准库，如 <code>Http</code>,<code>Buffer</code> 模块。</p><p><code>Node Bindings</code>: 是沟通<code>JS</code>和<code>C++</code>的桥梁，封装<code>V8</code>和<code>Libuv</code>的细节，向上层提供基础<code>API</code>服务。</p><p>第三层是支撑<code>Node.js</code>运行的关键，由<code>C/C++</code>实现：</p><ol><li><code>V8</code> 是<code>Google</code>开发的<code>JavaScript</code>引擎，提供<code>JavaScript</code>运行环境，可以说它就是<code>Node.js</code>的发动机。</li><li><code>Libuv</code> 是专门为<code>Node.js</code>开发的一个封装库，提供跨平台的异步<code>I/O</code>能力。</li><li><code>C-ares：</code>提供了异步处理<code>DNS</code>相关的能力。</li><li><code>http_parser</code>、<code>OpenSSL</code>、<code>zlib</code> 等：提供包括<code>http</code>解析、<code>SSL</code>、数据压缩等其他的能力。</li></ol>',108)]))}const m=e(t,[["render",s]]);export{g as __pageData,m as default};
