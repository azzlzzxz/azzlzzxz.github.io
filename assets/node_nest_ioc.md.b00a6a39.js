import{_ as l,B as p,o as d,c as t,x as e,D as c,z as a,Q as n,a as o}from"./chunks/framework.a5035e6c.js";const N=JSON.parse('{"title":"IOC","description":"","frontmatter":{},"headers":[],"relativePath":"node/nest/ioc.md","lastUpdated":1724827728000}'),r={name:"node/nest/ioc.md"},i=n(`<h1 id="ioc" tabindex="-1">IOC <a class="header-anchor" href="#ioc" aria-label="Permalink to &quot;IOC&quot;">​</a></h1><h2 id="ioc-解决了什么问题" tabindex="-1">✏️ IOC 解决了什么问题 <a class="header-anchor" href="#ioc-解决了什么问题" aria-label="Permalink to &quot;:pencil2: IOC 解决了什么问题&quot;">​</a></h2><p>后端系统里有很多对象：</p><ol><li><code>Controller 对象：</code>接收 <code>http</code> 请求，调用<code> Service</code>，返回响应。</li><li><code>Service 对象：</code>实现业务逻辑。</li><li><code>Repository 对象：</code>实现对数据库的增删改查。</li><li><code>DataSource 对象：</code>数据库链接对象。</li><li><code>Config 对象：</code>配置对象。</li></ol><p>这些对象错综复杂 💢：</p><p><code>Controller</code> 依赖了 <code>Service</code> 实现业务逻辑，<code>Service</code> 依赖了 <code>Repository</code> 来做增删改查，<code>Repository</code> 依赖 <code>DataSource</code> 来建立连接，<code>DataSource</code> 又需要从 <code>Config</code> 对象拿到用户名密码等信息。</p><p>这就导致了创建这些对象是很复杂的，你要理清它们之间的依赖关系，哪个先创建哪个后创建。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> config </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Config</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">username</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#F07178;">password</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxx</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> dataSource </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">DataSource</span><span style="color:#BABED8;">(config)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> repository </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Repository</span><span style="color:#BABED8;">(dataSource)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> service </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Service</span><span style="color:#BABED8;">(repository)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> controller </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Controller</span><span style="color:#BABED8;">(service)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>要经过一系列的初始化之后才可以使用 <code>Controller</code> 对象。</p><p>而且像 <code>config</code>、<code>dataSource</code>、<code>repository</code>、<code>service</code>、<code>controller</code> 等这些对象不需要每次都 <code>new</code> 一个新的，一直用一个就可以，也就是保持单例。</p><p>在应用初始化的时候，需要理清依赖的先后关系，创建一大堆对象组合起来，还要保证不要多次 <code>new</code>，这就很麻烦？</p><p>💡 <code>IOC</code> 就是解决这系列的问题的。</p><h2 id="那、什么是-ioc-🤔" tabindex="-1">那、什么是 <code>IOC</code> 🤔 <a class="header-anchor" href="#那、什么是-ioc-🤔" aria-label="Permalink to &quot;那、什么是 \`IOC\` 🤔&quot;">​</a></h2>`,13),D=e("code",null,"Nest",-1),y=e("code",null,"IOC（Inversion of Control，控制反转）",-1),u=e("code",null,"Nest",-1),B=e("code",null,"（DI）",-1),F=e("code",null,"IOC",-1),_=n('<h2 id="理解-ioc" tabindex="-1">理解 <code>IOC</code> <a class="header-anchor" href="#理解-ioc" aria-label="Permalink to &quot;理解 `IOC`&quot;">​</a></h2><p>💭 <code>IOC</code> 实现思路：我在 <code>class</code> 上声明依赖了啥，工具去分析我声明的依赖关系，根据先后顺序把对象创建好，再组装起来。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在 <code>Nest</code> 中，<code>IOC</code> 和依赖注入的核心概念是：</p><ol><li><p><code> Provider（提供者）：</code> <code>Provider </code> 是一个可被注入的类，它负责创建和管理特定类型的实例。在 <code>Nest</code> 中，常见的 <code>Provider</code> 类型包括服务类、仓储类、工厂类等。</p></li><li><p><code> Module（模块）：</code> <code>Module </code> 是一个逻辑单元，它用于组织和配置应用程序中的提供者。每个 <code>Nest</code> 应用程序都由多个模块组成。模块通过 <code>@Module</code> 装饰器来定义，并在 <code>imports</code> 属性中指定依赖的其他模块。</p></li><li><p><code> Dependency Injection Container（依赖注入容器）：</code> <code>Nest</code> 中的依赖注入容器负责管理和解决 <code>Provider</code> 之间的依赖关系。容器在应用程序启动时会扫描模块的依赖关系，并根据需要创建和注入 <code>Provider</code> 的实例。</p></li></ol></div><p>在使用 <code>IOC</code> 和依赖注入时，您可以通过在类的构造函数参数上使用 <code>@Inject()</code> 装饰器来声明依赖项。Nest 将根据这些声明来解析依赖关系，并在需要时提供依赖项的实例。</p><p>通过使用 <code>IOC</code> 和依赖注入，您可以轻松管理和组织复杂的应用程序结构，实现可扩展和可测试的代码。它还促进了模块化和松耦合的设计，使得代码更加清晰和可维护。</p><h2 id="injectable" tabindex="-1"><code>@Injectable</code> <a class="header-anchor" href="#injectable" aria-label="Permalink to &quot;`@Injectable`&quot;">​</a></h2><p>在 <code>Nest</code> 中，<code>@Injectable</code> 装饰器用于将类标记为可注入的依赖项。它是 <code>Nest</code> 中依赖注入系统的核心部分之一。</p><p>当您在类上应用 <code>@Injectable</code> 装饰器时，<code>Nest</code> 将能够根据需要创建类的实例，并将其注入到其他类中。这使得在 <code>Nest</code> 应用程序中使用依赖注入变得非常方便。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>@Injectable</code> 装饰器主要用于以下目的：</p><ol><li><p>依赖注入：通过在类的构造函数参数上使用 <code>@Injectable</code> 装饰器，您可以告诉 <code>Nest</code> 该类需要哪些依赖项。在需要创建类的实例时，<code>Nest</code> 会自动解析并提供这些依赖项。</p></li><li><p>单例模式：默认情况下，使用 <code>@Injectable</code> 装饰器标记的类在整个应用程序中是单例的。这意味着每次请求都将获得相同的实例。<code>Nest</code> 会负责创建并管理这些实例，以确保它们在需要时正确地共享。</p></li><li><p>循环依赖解析：<code>Nest</code> 支持解析循环依赖关系。当出现类之间的循环依赖时，您可以使用 <code>@Injectable</code> 装饰器来解决问题。<code>Nest</code> 将根据需要创建类的代理对象，以避免循环依赖引发的问题。</p></li></ol></div><p>总之，<code>@Injectable</code> 装饰器在 <code>Nest</code> 中是非常重要的，它允许您使用依赖注入来创建可维护和可扩展的应用程序。通过使用该装饰器，您可以轻松地管理类之间的依赖关系，并实现松耦合的代码架构</p><p>为什么 <code>Controller</code> 是单独的装饰器呢？</p><p>因为 <code>Service</code> 是可以被注入也是可以注入到别的对象的，所以用 <code>@Injectable</code> 声明。</p><p>而 <code>Controller</code> 只需要被注入，所以 <code>nest</code> 单独给它加了 <code>@Controller</code> 的装饰器。</p><h2 id="总之" tabindex="-1">总之 <a class="header-anchor" href="#总之" aria-label="Permalink to &quot;总之&quot;">​</a></h2><ol><li><p>后端系统有很多的对象，这些对象之间的关系错综复杂，如果手动创建并组装对象比较麻烦，所以后端框架一般都提供了 <code>IOC</code> 机制。</p></li><li><p><code>IOC</code> 机制是在 <code>class</code> 上标识哪些是可以被注入的，它的依赖是什么，然后从入口开始扫描这些对象和依赖，自动创建和组装对象。</p></li><li><p><code>Nest</code> 里通过 <code>@Controller</code> 声明可以被注入的 <code>controller</code>，通过 <code>@Injectable</code> 声明可以被注入也可以注入别的对象的 <code>provider</code>，然后在 <code>@Module</code> 声明的模块里引入。</p></li><li><p>并且 <code>Nest</code> 还提供了 <code>Module</code> 和 <code>Module</code> 之间的 <code>import</code>，可以引入别的模块的 <code>provider</code> 来注入。</p></li></ol>',15);function b(A,h,C,I,m,E){const s=p("font");return d(),t("div",null,[i,e("p",null,[e("strong",null,[c(s,{color:"FF9D00"},{default:a(()=>[o("在 "),D,o(" 中，"),y,o("是一种设计模式，它用于管理和解决类之间的依赖关系。")]),_:1})])]),e("p",null,[e("strong",null,[c(s,{color:"FF9D00"},{default:a(()=>[u,o(" 使用依赖注入"),B,o("作为实现 "),F,o(" 的机制。依赖注入是一种设计模式，它允许将依赖项动态地注入到一个类中，而不是在类内部直接创建这些依赖项的实例。这样做的好处是可以实现松耦合的代码，提高可测试性和可维护性。")]),_:1})])]),_])}const f=l(r,[["render",b]]);export{N as __pageData,f as default};
