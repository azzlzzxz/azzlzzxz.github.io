import{_ as n,B as l,o as c,c as p,N as a,x as t,a as e,D as r,z as d}from"./chunks/framework.2f525601.js";const k=JSON.parse('{"title":"Hooks 相关知识","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/base/hooks.md","lastUpdated":1729436528000}'),i={name:"frame/react/base/hooks.md"};function u(y,s,F,D,b,m){const o=l("font");return c(),p("div",null,[s[3]||(s[3]=a(`<h1 id="hooks-相关知识" tabindex="-1">Hooks 相关知识 <a class="header-anchor" href="#hooks-相关知识" aria-label="Permalink to &quot;Hooks 相关知识&quot;">​</a></h1><h2 id="hooks-要遵守的规则" tabindex="-1"><code>Hooks</code> 要遵守的规则 <a class="header-anchor" href="#hooks-要遵守的规则" aria-label="Permalink to &quot;\`Hooks\` 要遵守的规则&quot;">​</a></h2><ul><li>只在函数最顶层调用 <code>Hooks</code></li></ul><p>不要在循环、条件或嵌套函数中调用 <code>Hooks</code>。确保每次组件渲染时 <code>Hooks</code> 的调用顺序一致。这是因为 <code>React</code> 依赖于 <code>Hooks</code> 的调用顺序来管理组件的内部状态</p><ul><li>只在 <code>React</code> 函数组件中调用 <code>Hooks</code></li></ul><p>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hooks</code>。<code>Hooks</code> 只能在 <code>React</code> 的函数组件或自定义的 <code>Hook（函数名以</code> <code>use</code> 开头）中调用</p><h2 id="setstate-是同步还是异步" tabindex="-1">setState 是同步还是异步 <a class="header-anchor" href="#setstate-是同步还是异步" aria-label="Permalink to &quot;setState 是同步还是异步&quot;">​</a></h2><p><code>setState</code> 在类组件中是 <code>this.setState</code> 方法，在函数组件中是 <code>useState</code> 返回值的修改函数 <code>setState</code> 用于变更状态，触发组件重新渲染，更新视图 <code>UI</code></p><ul><li>关于<code>useState</code>的实现可以看这里 <a href="/rsource/react/useState"><u>React 18.2 | useState 实现 🚀</u></a></li></ul><h3 id="在-react-18-之前" tabindex="-1">在 <code>React 18</code> 之前 <a class="header-anchor" href="#在-react-18-之前" aria-label="Permalink to &quot;在 \`React 18\` 之前&quot;">​</a></h3><p>在 <code>React 18</code> 之前，只要在 <code>React</code> 可以控制的地方，<code>setState</code> 的执行都是异步的，比如在 <code>React</code> 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略</p><p>而在 <code>React</code> 无法控制的地方，如监听原生事件和异步调用的地方，<code>setState</code> 的执行都是就是同步的。比如在 <code>addEventListener</code>、<code>setTimeout</code>、<code>Promise</code> 等的回调函数中</p><h3 id="在-react-18-之后" tabindex="-1">在 <code>React 18</code> 之后 <a class="header-anchor" href="#在-react-18-之后" aria-label="Permalink to &quot;在 \`React 18\` 之后&quot;">​</a></h3><p>在 <code>concurrent</code> 模式下，由于默认启用了并发更新，所以 <code>setState</code> 的执行都是异步的，即不管是在 <code>React</code> 可以控制的地方还是无法控制的地方，默认都会走合并操作，延迟更新的策略</p><div class="tip custom-block"><p class="custom-block-title"><code>setState</code> 为什么是异步的？</p><ul><li>性能优化、减少渲染次数</li></ul><p>从源码的角度分析，在执行任务调度之前，回去判断当前正在更新的 lane 优先级和老的更新优先级做对比，如果优先级一样就开启了批处理，就不需要再次调度新任务执行更新了。（源码地址 <a href="https://github.com/azzlzzxz/react-v18.2.0/blob/75de845d69876d84a4a8b226c5f2e6203328b8ee/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L715" target="_blank" rel="noreferrer"><u>批处理</u></a>）</p><ul><li>保持内部一致性</li></ul></div><h2 id="闭包陷阱" tabindex="-1">闭包陷阱 <a class="header-anchor" href="#闭包陷阱" aria-label="Permalink to &quot;闭包陷阱&quot;">​</a></h2><p>闭包陷阱就是 <code>effect</code> 函数等引用了 <code>state</code>，形成了闭包，但是并没有把 <code>state</code> 加到依赖数组里，导致执行 <code>effect</code> 时用的 <code>state</code> 还是之前的。</p><blockquote><p>举个 🌰</p></blockquote><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">useEffect</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">useState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">App</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setInterval</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">count</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">setCount</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#BABED8;"> App</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/react/hook_trap.gif" alt="hook_trap"></p><p>可以看到，<code>setCount</code> 时拿到的 <code>count</code> 一直是 <code>0</code></p><p><strong>解决方案：</strong></p><ul><li><p>使用 <code>setState</code> 的函数的形式，从参数拿到上次的 <code>state</code>，这样就不会形成闭包了，或者用 <code>useReducer</code>，直接 <code>dispatch action</code>，而不是直接操作 <code>state</code>，这样也不会形成闭包</p></li><li><p>把用到的 <code>state</code> 加到依赖数组里，这样 <code>state</code> 变了就会重新跑 <code>effect</code> 函数，引用新的 <code>state</code></p></li><li><p>使用 <code>useRef</code> 保存每次渲染的值，用到的时候从 <code>ref.current</code> 取</p></li></ul><h2 id="usememo和usecallback" tabindex="-1"><code>useMemo</code>和<code>useCallback</code> <a class="header-anchor" href="#usememo和usecallback" aria-label="Permalink to &quot;\`useMemo\`和\`useCallback\`&quot;">​</a></h2><p>先来看看<code>React</code>自己对这两个<code>hook</code>的定义：</p><ul><li><a href="https://zh-hans.react.dev/reference/react/useMemo" target="_blank" rel="noreferrer"><u><code>useMemo</code></u></a>：<code>useMemo</code> 是一个 <code>React Hook</code>，它在每次重新渲染的时候能够缓存计算的结果。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> cachedValue </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useMemo</span><span style="color:#BABED8;">(calculateValue</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> dependencies)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><a href="https://zh-hans.react.dev/reference/react/useCallback" target="_blank" rel="noreferrer"><u><code>useCallback</code></u></a>：<code>useCallback</code> 是一个允许你在多次渲染中缓存函数的 <code>React Hook</code>。</li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> cachedFn </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useCallback</span><span style="color:#BABED8;">(fn</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> dependencies)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,29)),t("p",null,[s[1]||(s[1]=e("这也就是为什么使用他们的原因**")),r(o,{color:"#FF9D00"},{default:d(()=>s[0]||(s[0]=[e("缓存")])),_:1}),s[2]||(s[2]=e("**"))]),s[4]||(s[4]=a(`<p>在每次重渲染之间缓存数据。如果一个值或函数被包裹在这两个 <code>hooks</code> 中，<code>react</code> 就会在首次渲染时缓存这个值或函数。在接下来的每次重渲染时，都会返回这个缓存的值。如果不使用它们，所有非原始类型的值，如 <code>array</code>、<code>object</code>，或 <code>function</code>，都会在每一次重渲染时被彻底重新创建。</p><blockquote><p>举个 🌰</p></blockquote><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> Component </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> test</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#F07178;"> [</span><span style="color:#BABED8;">a</span><span style="color:#F07178;">])</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>a</code> 是 <code>useEffect</code> 依赖。在每次重新渲染<code>Component</code>时，<code>React</code> 都会将其与之前的值进行比较。<code>a</code> 是在 <code>Component</code> 中定义的对象，这意味着在每次重新渲染时，它都会从头开始重新创建。因此，比较<code>重渲染之前</code>的 <code>a</code> 和 <code>重渲染之后</code>的 <code>a</code>，结果都会是 <code>false</code>，所以被 <code>useEffect</code> 包裹的函数也将会在每次重渲染的过程中触发调用。</p><p>这时候用<code>useMemo</code>或<code>useCallback</code>，把它缓存起来，就可以很好的进行优化，只有在依赖项确实发生变化的时候才会触发回调。</p><p><strong>但是，<code>useMemo</code>和<code>useCallback</code>，只有在重渲染的过程中才有用。在初始渲染过程中，它们会让 <code>React</code> 做很多额外的工作，也就意味着你的应用在初始渲染过程中会[稍稍更慢]一些</strong></p><h3 id="不要滥用-usememo或usecallback" tabindex="-1">不要滥用 <code>useMemo</code>或<code>useCallback</code> <a class="header-anchor" href="#不要滥用-usememo或usecallback" aria-label="Permalink to &quot;不要滥用 \`useMemo\`或\`useCallback\`&quot;">​</a></h3><p>首先一个组件什么时候会重新渲染自己？</p><ul><li><p>当 <code>state</code> 或者 <code>prop</code> 发生变化的时候，组件就会重渲染自己</p></li><li><p>当组件的父组件重渲染，也就是说，当一个组件重渲染它自己的时候，它也会同时重渲染它的 <code>children</code></p></li></ul><p>那我们就可以知道，<code>useMemo</code>和<code>useCallback</code>作用于 <code>prop</code> 并不能避免组件重渲染，只有当每一个 <code>prop</code> 都被缓存，且组件本身也被缓存的情况下，重渲染才能被避免。</p><p>如果组件代码里有以下情形，我们可以毫无心理负担地删掉 <code>useMemo</code> 和 <code>useCallback</code>：</p><ul><li><p>它们作为属性直接或通过依赖链传递给 <code>DOM</code> 元素</p></li><li><p>它们被作为 <code>props</code>，直接或通过依赖链传递到某个未被缓存的组件上</p></li><li><p>它们被作为 <code>props</code>，直接或通过一系列依赖项传递给至少有一个 prop 未缓存的组件</p></li></ul><div class="info custom-block"><p class="custom-block-title">相关资料</p><ul><li><p><a href="https://www.developerway.com/posts/how-to-use-memo-use-callback#part4" target="_blank" rel="noreferrer"><u>如何使用 Memo 和 useCallback</u></a></p></li><li><p><a href="https://juejin.cn/post/7251802404877893689" target="_blank" rel="noreferrer"><u>「好文翻译」为什么你可以删除 90% 的 useMemo 和 useCallback</u></a></p></li></ul></div>`,13))])}const f=n(i,[["render",u]]);export{k as __pageData,f as default};
