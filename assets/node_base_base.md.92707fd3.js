import{_ as o,o as d,c,N as a}from"./chunks/framework.2f525601.js";const u=JSON.parse('{"title":"Node","description":"","frontmatter":{},"headers":[],"relativePath":"node/base/base.md","lastUpdated":1729053814000}'),s={name:"node/base/base.md"};function t(n,e,i,p,l,r){return d(),c("div",null,e[0]||(e[0]=[a('<h1 id="node" tabindex="-1">Node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;Node&quot;">​</a></h1><p><code>Node</code> 不是一门语言，其核心就是一个让 <code>JS</code> 运行在服务端的一个运行时。</p><p><code>Node.js</code> 最大的特点就是使用 异步式 <code>I/O</code> 与 事件驱动 的架构设计。</p><p>对于高并发的解决方案，传统的架构是多线程模型，而 <code>Node.js</code> 使用的是 单线程 模型，对于所有 <code>I/O</code> 都使用非阻塞的异步式的请求方式，避免了频繁的线程切换。</p><p>异步式 <code>I/O</code> 是这样实现的：由于大多数现代内核都是多线程的，所以它们可以处理在后台执行的多个操作。</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/node_async.jpg" alt="node_async"></p><p><code>Node.js</code> 在执行的过程中会维护一个事件队列，程序在执行时进入 事件循环 等待下一个事件到来。</p><p>当事件到来时，事件循环将操作交给系统内核，当一个操作完成后内核会告诉 <code>Nodejs</code>，对应的回调会被推送到事件队列，等待程序进程进行处理。</p><h2 id="nodejs-的架构" tabindex="-1"><code>Nodejs</code> 的架构 <a class="header-anchor" href="#nodejs-的架构" aria-label="Permalink to &quot;`Nodejs` 的架构&quot;">​</a></h2><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/node_1.png" alt="node"></p><p><code>Node.js</code> 使用 <code>V8</code> 作为 <code>JavaScript</code> 引擎，使用高效的 <code>libev</code> 和 <code>libeio</code> 库支持事件驱动和异步式 <code>I/O</code>。</p><p><code>Node.js</code> 的开发者在 <code>libev</code> 和 <code>libeio</code> 的基础上还抽象出了层 <code>libuv</code>。对于 <code>POSIX1</code> 操作系统，<code>libuv</code> 通过封装 <code>libev</code> 和 <code>libeio</code> 来利用 <code>epoll</code> 或 <code>kqueue</code>。在 <code>Windows</code> 下，<code>libuv</code> 使用了 <code>Windows</code> 的 <code>IOCP</code> 机制，以在不同平台下实现同样的高性能。</p><h2 id="nodejs-的运行机制" tabindex="-1"><code>Nodejs</code> 的运行机制 <a class="header-anchor" href="#nodejs-的运行机制" aria-label="Permalink to &quot;`Nodejs` 的运行机制&quot;">​</a></h2><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/node_system.jpg" alt="node_system"></p><ol><li><p><code>V8</code> 引擎解析 <code>JavaScript</code> 脚本。</p></li><li><p>解析后的代码，调用 <code>Node API</code>。</p></li><li><p><code>libuv</code> 库负责 <code>Node API</code> 的执行。它将不同的任务分配给不同的线程，形成一个 <code>Event Loop（事件循环）</code>，以异步的方式将任务的执行结果返回给 <code>V8</code> 引擎。</p></li><li><p><code>V8</code> 引擎再将结果返回给用户</p></li></ol>',15)]))}const b=o(s,[["render",t]]);export{u as __pageData,b as default};
