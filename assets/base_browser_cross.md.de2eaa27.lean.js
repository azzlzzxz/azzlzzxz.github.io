import{_ as o,o as c,c as d,N as l}from"./chunks/framework.6198c6ab.js";const h=JSON.parse('{"title":"浏览器的跨域","description":"","frontmatter":{},"headers":[],"relativePath":"base/browser/cross.md","lastUpdated":1725978992000}'),i={name:"base/browser/cross.md"};function t(a,e,r,s,n,p){return c(),d("div",null,e[0]||(e[0]=[l('<h1 id="浏览器的跨域" tabindex="-1">浏览器的跨域 <a class="header-anchor" href="#浏览器的跨域" aria-label="Permalink to &quot;浏览器的跨域&quot;">​</a></h1><p>当请求<code>URL</code>的协议、域名、端口三者之间任意一个与当前页面<code>url</code>不同即为跨域</p><div class="tip custom-block"><p class="custom-block-title">为什么会产生跨域 - 浏览器的同源策略</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noreferrer"><u>同源策略</u></a>是浏览器一个重要的安全策略，它用于限制一个<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin" target="_blank" rel="noreferrer"><u>源</u></a> <code>(origin)</code> 的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介</p><p>同源是指两个 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/URL" target="_blank" rel="noreferrer"><u><code>URL</code></u></a> 的 协议、域名(子域名 + 主域名)、端口号 都相同，否则就会出现跨域</p></div><h2 id="同源策略的限制" tabindex="-1">同源策略的限制 <a class="header-anchor" href="#同源策略的限制" aria-label="Permalink to &quot;同源策略的限制&quot;">​</a></h2><ul><li>限制向非同源地址发送<code>Ajax</code>请求</li><li>限制读取非同源网页的<code>cookie</code>、<code>localStorage</code>、<code>indexedDB</code></li><li>限制跨源脚本 <code>API</code> 访问，无法获取 <code>DOM</code></li></ul><h2 id="跨域解决方案" tabindex="-1">跨域解决方案 <a class="header-anchor" href="#跨域解决方案" aria-label="Permalink to &quot;跨域解决方案&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">常用的跨域解决方案</p><ul><li><code>CORS</code></li><li><code>JSONP</code></li><li><code>Nginx</code>反向代理</li><li><code>WebSocket</code></li><li><code>window.postMesssage</code></li><li><code>document.domain</code></li></ul></div><h3 id="cors跨源资源共享" tabindex="-1"><code>CORS</code>跨源资源共享 <a class="header-anchor" href="#cors跨源资源共享" aria-label="Permalink to &quot;`CORS`跨源资源共享&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noreferrer"><u><code>CORS</code></u></a>是一种基于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP" target="_blank" rel="noreferrer"><u>&lt;HTTP</u></a> 头的机制，该机制允许浏览器向跨源服务器发出 <code>XMLHttpRequest</code> 请求，从而解决了 <code>AJAX</code> 只能同源使用的限制。</p><blockquote><p><code>CORS</code> 需要浏览器和服务器同时支持，目前所有浏览器均已支持，只需服务器配置即可使用</p></blockquote><p>浏览器将<code>CORS</code>请求分成两类：简单请求<code>（simple request）</code>和非简单请求<code>（not-simple-request）</code></p><h4 id="简单请求" tabindex="-1">简单请求 <a class="header-anchor" href="#简单请求" aria-label="Permalink to &quot;简单请求&quot;">​</a></h4><div class="tip custom-block"><p class="custom-block-title">同时满足下列三大条件，就属于简单请求</p><ul><li>请求方式只能是： <ul><li><code>GET</code></li><li><code>POST</code></li><li><code>HEAD</code></li></ul></li><li><code>HTTP</code> 请求头限制这几种字段： <ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>Last-Event-ID</code></li></ul></li><li><code>Content-type</code> 只能取： <ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li><li>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器(使用 <code>XMLHttpRequest.upload</code> <code>属性访问XMLHttpRequestUpload</code> 对象)</li><li>请求中没有使用 <code>ReadableStream</code> 对象</li></ul></div><p><strong>简单请求基本流程</strong></p><ol><li><p>对于简单请求，浏览器直接请求，会在请求头信息中，增加一个 <code>origin</code> 字段，来说明本次请求来自哪个源（协议 + 域名 + 端口）。</p></li><li><p>服务器根据<code>origin</code>这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段，三个与 <code>CORS</code> 请求相关，都是以 <code>Access-Control-</code>开头。</p></li></ol><div class="tip custom-block"><p class="custom-block-title">简单请求响应头中的 <code>CORS</code> 字段</p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin" target="_blank" rel="noreferrer"><u><code>Access-Control-Allow-Origin</code></u></a>：（必须），<code>*</code> (表示接受任意域名的请求)，还可以指定域名。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials" target="_blank" rel="noreferrer"><u><code>Access-Control-Allow-Credentials</code></u></a>：（可选），是个布尔值，表示响应标头告诉浏览器服务器是否允许 HTTP 跨源请求携带凭据，例如： <code>cookie</code>、<code>TLS</code>客户端证书、包含用户名和密码的认证标头，（注意：如果 <code>Access-Control-Allow-Origin</code> 字段设置<code>*</code>，此字段设为 <code>true</code> 无效）。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers" target="_blank" rel="noreferrer"><u><code>Access-Control-Allow-Headers</code></u></a>：（可选）， 用于响应包含了 <code>Access-Control-Request-Headers</code> 的预检请求，以指示在实际请求中可以使用哪些 <code>HTTP</code> 标头，里面可以获取 <code>Cache-Control</code>、<code>Content-Type</code>、<code>Content-Language</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>，如果想要拿到其他字段，就必须在 <code>Access-Control-Expose-Headers</code>里面指定。</li></ol></div><p><code>CORS</code> 请求默认不发送 <code>Cookie</code>，如果需要发送需要满足如下条件：</p><ul><li>服务器必须设置 <code>Access-Control-Allow-Credentials</code>: <code>true</code></li><li><code>Access-Control-Allow-Origin</code> 字段不能为 <code>*</code></li><li><code>AJAX</code> 请求的配置项需设置 <code>withCredentials = true</code></li></ul><h4 id="非简单请求" tabindex="-1">非简单请求 <a class="header-anchor" href="#非简单请求" aria-label="Permalink to &quot;非简单请求&quot;">​</a></h4><p>非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是 <code>PUT</code> 或者 <code>DELETE</code>，或者 <code>Content-Type</code> 字段类型是 <code>application/json</code>，都会在正式通信之前，增加一次 <code>HTTP</code> 请求，称之为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Preflight_request" target="_blank" rel="noreferrer"><u>预检请求</u></a>，用于获取服务器是否允许该实际请求，同时避免跨域请求对服务器的用户数据产生预期之外的影响。</p><div class="tip custom-block"><p class="custom-block-title">预检请求</p><p>浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的 <code>XMLHttpRequest</code> 请求，否则会报错。（备注：如果预检请求没有通过，就不会发正式请求，需要服务器设置）。</p><p>预检请求用的请求方法是 <code>OPTIONS</code> 表示这个请求是用来询问的</p><ul><li>在预检请求请求头信息里会包含如下字段 <ul><li><code>Origin</code>: 表示本次请求来自哪个源</li><li><code>Access-Control-Request-Method</code>: 用于列出浏览器的 <code>CORS</code> 请求会用到哪些 <code>HTTP</code> 方法</li><li><code>Access-Control-Request-Headers</code>(可选): 指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段</li></ul></li><li>服务器通过后会在预检请求响应头中设置如下字段 <ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Credentials</code>(可选)</li><li><code>Access-Control-Allow-Methods</code>: 表示服务器支持的所有跨域请求的方法(为了避免多次预检请求)</li><li><code>Access-Control-Allow-Headers</code>: 表示服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段</li><li><code>Access-Control-Max-Age</code>(可选): 用来指定本次预检请求的有效期单位为秒，在有效期内将不发出另一条预检请求</li></ul></li></ul></div><p>一旦服务器通过了预检请求，以后每次浏览器正常的 <code>CORS</code> 请求，就都跟简单请求一样会有一个 <code>Origin</code> 头信息字段。服务器的回应也都会有一个 <code>Access-Control-Allow-Origin</code> 头信息字段</p><h3 id="jsonp" tabindex="-1"><code>JSONP</code> <a class="header-anchor" href="#jsonp" aria-label="Permalink to &quot;`JSONP`&quot;">​</a></h3><p><code>JSONP</code> 是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，当前源可以得到从其他来源动态产生的 <code>JSON</code> 数据</p><p><strong><code>JSONP</code> 请求过程流程</strong></p><ol><li>前端定义一个解析的回调函数</li><li>创建 <code>script</code> 标签，其 <code>src</code> 指向接口地址并拼接好参数和回调函数名</li><li>后端处理数据并将其拼接到前端传入的回调函数中(拼接好的数据必须是一个合法的 <code>JavaScript</code> 脚本 )</li><li>浏览器执行后端返回的 <code>JavaScript</code> 脚本代码(调用定义好的回调函数)并删除刚创建的 <code>script</code> 标签</li></ol><div class="tip custom-block"><p class="custom-block-title">JSONP 跨域优缺点</p><ul><li>优点: 实现简单，兼容性好</li><li>缺点 <ul><li>只支持 <code>GET</code> 请求</li><li>容易遭受 <code>XSS</code> 攻击</li></ul></li></ul></div><h3 id="nginx反向代理" tabindex="-1"><code>Nginx</code>反向代理 <a class="header-anchor" href="#nginx反向代理" aria-label="Permalink to &quot;`Nginx`反向代理&quot;">​</a></h3><h3 id="webscoket" tabindex="-1"><code>WebScoket</code> <a class="header-anchor" href="#webscoket" aria-label="Permalink to &quot;`WebScoket`&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noreferrer"><u><code>WebSocket</code></u></a>： 一种浏览器与服务器进行全双工通讯的网络技术，也就是客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。</p><p>这种方式本质没有使用了 <code>HTTP</code> 的响应头, 因此也没有跨域的限制。</p><h3 id="window-postmessage" tabindex="-1"><code>window.postMessage</code> <a class="header-anchor" href="#window-postmessage" aria-label="Permalink to &quot;`window.postMessage`&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noreferrer"><u><code>window.postMessage()</code></u></a> 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 <code>https）</code>，端口号（<code>443</code> 为 <code>https</code> 的默认值），以及主机 (两个页面的模数 <code>Document.domain</code>设置为相同的值) 时，这两个脚本才能相互通信。<code>window.postMessage()</code> 方法提供了一种受控机制来规避此限制。</p><p>它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的<code>iframe</code>消息传递</li></ul><h3 id="document-domain" tabindex="-1"><code>document.domain</code> <a class="header-anchor" href="#document-domain" aria-label="Permalink to &quot;`document.domain`&quot;">​</a></h3>',36)]))}const b=o(i,[["render",t]]);export{h as __pageData,b as default};
