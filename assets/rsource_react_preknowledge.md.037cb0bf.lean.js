import{_ as a,o as t,c as o,N as c}from"./chunks/framework.cbb5d7f0.js";const u=JSON.parse('{"title":"前置知识","description":"","frontmatter":{},"headers":[],"relativePath":"rsource/react/preknowledge.md","lastUpdated":1726939810000}'),r={name:"rsource/react/preknowledge.md"};function l(d,e,i,n,s,h){return t(),o("div",null,e[0]||(e[0]=[c('<h1 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h1><p>在解析<code>React</code>源码前，我们先了解一些前置知识</p><h2 id="位运算符" tabindex="-1">位运算符 <a class="header-anchor" href="#位运算符" aria-label="Permalink to &quot;位运算符&quot;">​</a></h2><h2 id="有标识的while循环" tabindex="-1">有标识的<code>while</code>循环 <a class="header-anchor" href="#有标识的while循环" aria-label="Permalink to &quot;有标识的`while`循环&quot;">​</a></h2><h2 id="事件委托-代理" tabindex="-1">事件委托（代理） <a class="header-anchor" href="#事件委托-代理" aria-label="Permalink to &quot;事件委托（代理）&quot;">​</a></h2><p>从<code>React 17.0.0</code>开始, <code>React</code> 不会再将事件处理添加到 <code>document</code> 上, 而是将事件处理添加到渲染 <code>React</code> 树的根 <code>DOM</code> 容器中</p><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/react/react_17_delegation_authority.png" alt="react_17_delegation_authority"></p><p>图中清晰的展示了<code>v17.0.0</code>的改动, 无论是在<code>document</code>还是根 <code>DOM</code> 容器上监听事件, 都可以归为<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events" target="_blank" rel="noreferrer"><u>事件委托(代理)</u></a></p><h3 id="那什么是事件委托呢" tabindex="-1">那什么是事件委托呢？ <a class="header-anchor" href="#那什么是事件委托呢" aria-label="Permalink to &quot;那什么是事件委托呢？&quot;">​</a></h3><p>事件委托是把原本需要绑定在子元素的事件委托给父元素，让父元素负责事件监听，事件委托是利用事件冒泡来实现的</p><div class="tip custom-block"><p class="custom-block-title">优点</p><ul><li>可以大量节省内存占用，减少事件注册</li><li>当新增子对象时无需再次对其绑定</li></ul></div><p><img src="https://steinsgate.oss-cn-hangzhou.aliyuncs.com/react/react_event_entrust.jpg" alt="react_event_entrust"></p>',12)]))}const m=a(r,[["render",l]]);export{u as __pageData,m as default};
