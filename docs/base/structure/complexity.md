# 时间 & 空间复杂度

判断一个算法的好坏，一般从执行时间和占用空间来看，执行时间越短，占用的内存空间越小，那么它就是好的算法。对应的，我们常常用时间复杂度代表执行时间，空间复杂度代表占用的内存空间。

## 时间复杂度

时间复杂度用于描述算法执行所需时间与输入规模之间的关系。它通常表示为一个函数 \( `T(n)` \)，其中 \( `n` \) 是输入的规模。随着`n`的不断增大，时间复杂度不断增大。

### **常见的时间复杂度**

- **常数时间复杂度 \( `O(1)` \)**

  - 执行时间不随输入规模的增加而变化。

  - 例如：访问数组中的一个元素。

- **对数时间复杂度 \( `O(log n)` \)**

  - 执行时间随着输入规模的增加而增加，但增加的速度减慢。

  - 例如：二分查找。

- **线性时间复杂度 \( `O(n)` \)**

  - 执行时间与输入规模成正比。

  - 例如：遍历一个数组。

- **线性对数时间复杂度 \( `O(n \log n)` \)**
  - 常见于高效的排序算法，如归并排序和快速排序。
- **平方时间复杂度 \( `O(n^2)` \)**

  - 执行时间与输入规模的平方成正比。

  - 例如：嵌套循环遍历二维数组。

- **立方时间复杂度 \( `O(n^3)` \)**

  - 通常出现在三重嵌套循环的算法中。

- **指数时间复杂度 \( `O(2^n)` \)** 和 **阶乘时间复杂度 \( `O(n!)` \)**

  - 执行时间随着输入规模的增加而呈指数或阶乘增长，通常被认为是效率低下的算法。

  - 例如：解决某些组合问题的回溯算法。

### **时间复杂度的计算**

在分析时间复杂度时，通常关注以下几点：

- **基本操作**：算法中最频繁执行的操作。

- **最坏情况**：对时间复杂度的最严格评估，通常分析在输入的最不利情况下算法的表现。
- **大 O 符号**：用于描述算法的上界，忽略低阶项和常数系数，专注于输入规模增长时的增长率。

### 举几个 🌰

- 如果算法的执行时间不随`n`的增加而增长，假如算法中有上千条语句，执行时间也不过是一个较大的常数。

此类算法的时间复杂度是`O(1)`

🌰 代码执行`100`次，是一个常数，复杂度也是`O(1)`。

```js
let x = 1
while (x < 100) {
  x++
}
```

- 有多个循环语句时候，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的方法决定的。

在 👇 `for`循环当中，外层循环每执行一次，内层循环要执行`n`次，执行次数是根据`n`所决定的，时间复杂度是`O(n^2)`

```js
for (i = 0; i < n; i++) {
  for (j = 0; j < n; j++) {
    // ...code
  }
}
```

- 循环不仅与`n`有关，还与执行循环判断条件有关。

🌰 在 👇 代码中，如果`arr[i]`不等于`1`的话，时间复杂度是`O(n)`。如果`arr[i]`等于`1`的话，循环不执行，时间复杂度是`O(0)`。

```js
for (var i = 0; i < n && arr[i] != 1; i++) {
  // ...code
}
```

## 空间复杂度

空间复杂度用于描述算法在运行过程中所需的存储空间与输入规模之间的关系。

它通常表示为一个函数 \( `S(n)` \)，其中 \( `n` \) 是输入的规模。空间复杂度评估算法所需的内存量，包括输入数据的大小、辅助空间和其他临时变量所需的空间。

### **常见的空间复杂度**

- **常数空间复杂度 \( `O(1)` \)**

  - 算法所需的空间不随输入规模的变化而变化。

  - 例如：使用有限数量的变量。

- **线性空间复杂度 \( `O(n)` \)**

  - 所需的空间与输入规模成正比。

  - 例如：存储输入数组的副本或创建与输入数组同样大小的数组。

- **平方空间复杂度 \( `O(n^2)` \)**

  - 在某些情况下，如使用二维数组（例如动态规划的表格）时可能会出现。

- **递归空间复杂度**

  - 递归调用时会消耗栈空间，通常与递归深度有关。例如，深度为 \( `n` \) 的递归调用通常会有 \( `O(n)` \) 的空间复杂度。

### **空间复杂度的计算**

在分析空间复杂度时，通常关注以下几点：

- **输入空间**：算法需要存储的输入数据大小。

- **辅助空间**：额外的空间，用于存储中间变量或临时数据结构。

- **递归栈空间**：在递归算法中，栈的深度直接影响空间复杂度。

> 举个 🌰
>
> 递归实现，调用`fun`函数，每次都创建`1`个变量`k`。调用`n`次，空间复杂度`O(n*1) = O(n)`

```js
function fun(n) {
  let k = 10
  if (n === k) {
    return n
  } else {
    return fun(++n)
  }
}
```
